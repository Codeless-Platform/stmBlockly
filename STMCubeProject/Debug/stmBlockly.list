
stmBlockly.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000104c  08000130  08000130  00010130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000160  0800117c  0800117c  0001117c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080012dc  080012dc  000112e4  2**0
                  CONTENTS
  4 .ARM          00000000  080012dc  080012dc  000112e4  2**0
                  CONTENTS
  5 .preinit_array 00000000  080012dc  080012e4  000112e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080012dc  080012dc  000112dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080012e0  080012e0  000112e0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000000  20000000  20000000  000112e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000120  20000000  080012e4  00020000  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000120  080012e4  00020120  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  000112e4  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  0001130d  2**0
                  CONTENTS, READONLY
 13 .debug_info   00002a6e  00000000  00000000  00011350  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00000e8e  00000000  00000000  00013dbe  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000398  00000000  00000000  00014c50  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000290  00000000  00000000  00014fe8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000015aa  00000000  00000000  00015278  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00005b90  00000000  00000000  00016822  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0000bc68  00000000  00000000  0001c3b2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00000c20  00000000  00000000  0002801c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000062  00000000  00000000  00028c3c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000130 <__do_global_dtors_aux>:
 8000130:	b510      	push	{r4, lr}
 8000132:	4c05      	ldr	r4, [pc, #20]	; (8000148 <__do_global_dtors_aux+0x18>)
 8000134:	7823      	ldrb	r3, [r4, #0]
 8000136:	b933      	cbnz	r3, 8000146 <__do_global_dtors_aux+0x16>
 8000138:	4b04      	ldr	r3, [pc, #16]	; (800014c <__do_global_dtors_aux+0x1c>)
 800013a:	b113      	cbz	r3, 8000142 <__do_global_dtors_aux+0x12>
 800013c:	4804      	ldr	r0, [pc, #16]	; (8000150 <__do_global_dtors_aux+0x20>)
 800013e:	f3af 8000 	nop.w
 8000142:	2301      	movs	r3, #1
 8000144:	7023      	strb	r3, [r4, #0]
 8000146:	bd10      	pop	{r4, pc}
 8000148:	20000000 	.word	0x20000000
 800014c:	00000000 	.word	0x00000000
 8000150:	08001164 	.word	0x08001164

08000154 <frame_dummy>:
 8000154:	b508      	push	{r3, lr}
 8000156:	4b03      	ldr	r3, [pc, #12]	; (8000164 <frame_dummy+0x10>)
 8000158:	b11b      	cbz	r3, 8000162 <frame_dummy+0xe>
 800015a:	4903      	ldr	r1, [pc, #12]	; (8000168 <frame_dummy+0x14>)
 800015c:	4803      	ldr	r0, [pc, #12]	; (800016c <frame_dummy+0x18>)
 800015e:	f3af 8000 	nop.w
 8000162:	bd08      	pop	{r3, pc}
 8000164:	00000000 	.word	0x00000000
 8000168:	20000004 	.word	0x20000004
 800016c:	08001164 	.word	0x08001164

08000170 <Led_Matrix_init>:
		{ 0x41, 0x22, 0x14, 0x8, 0x8, 0x8, 0x8, 0x8 }, //Y
		{ 0x0, 0x7F, 0x2, 0x4, 0x8, 0x10, 0x20, 0x7F }, //Z
};
uint16 G_CS ,G_MOSI,G_CLK;
GPIO_Registers_t *GPIOx, *CS_GPIO;
void Led_Matrix_init(SPI_Registers_t *SPIx, uint16 CS_PIN, GPIO_Registers_t *CS_GPIOx) {
 8000170:	b580      	push	{r7, lr}
 8000172:	b08c      	sub	sp, #48	; 0x30
 8000174:	af00      	add	r7, sp, #0
 8000176:	60f8      	str	r0, [r7, #12]
 8000178:	460b      	mov	r3, r1
 800017a:	607a      	str	r2, [r7, #4]
 800017c:	817b      	strh	r3, [r7, #10]
	STK_init();
 800017e:	f000 fef5 	bl	8000f6c <STK_init>
	RCC_CLK_EN(APB2_ID, GPIOA_ID);
 8000182:	2102      	movs	r1, #2
 8000184:	2001      	movs	r0, #1
 8000186:	f000 fcc7 	bl	8000b18 <RCC_CLK_EN>
	G_CS = CS_PIN;
 800018a:	4a38      	ldr	r2, [pc, #224]	; (800026c <Led_Matrix_init+0xfc>)
 800018c:	897b      	ldrh	r3, [r7, #10]
 800018e:	8013      	strh	r3, [r2, #0]
	CS_GPIO = CS_GPIOx;
 8000190:	4a37      	ldr	r2, [pc, #220]	; (8000270 <Led_Matrix_init+0x100>)
 8000192:	687b      	ldr	r3, [r7, #4]
 8000194:	6013      	str	r3, [r2, #0]
	if(SPIx == SPI1){
 8000196:	68fb      	ldr	r3, [r7, #12]
 8000198:	4a36      	ldr	r2, [pc, #216]	; (8000274 <Led_Matrix_init+0x104>)
 800019a:	4293      	cmp	r3, r2
 800019c:	d109      	bne.n	80001b2 <Led_Matrix_init+0x42>
		G_MOSI = PIN_7;
 800019e:	4b36      	ldr	r3, [pc, #216]	; (8000278 <Led_Matrix_init+0x108>)
 80001a0:	2280      	movs	r2, #128	; 0x80
 80001a2:	801a      	strh	r2, [r3, #0]
		G_CLK = PIN_5;
 80001a4:	4b35      	ldr	r3, [pc, #212]	; (800027c <Led_Matrix_init+0x10c>)
 80001a6:	2220      	movs	r2, #32
 80001a8:	801a      	strh	r2, [r3, #0]
		GPIOx = GPIOA;
 80001aa:	4b35      	ldr	r3, [pc, #212]	; (8000280 <Led_Matrix_init+0x110>)
 80001ac:	4a35      	ldr	r2, [pc, #212]	; (8000284 <Led_Matrix_init+0x114>)
 80001ae:	601a      	str	r2, [r3, #0]
 80001b0:	e00e      	b.n	80001d0 <Led_Matrix_init+0x60>
	}else if(SPIx == SPI2){
 80001b2:	68fb      	ldr	r3, [r7, #12]
 80001b4:	4a34      	ldr	r2, [pc, #208]	; (8000288 <Led_Matrix_init+0x118>)
 80001b6:	4293      	cmp	r3, r2
 80001b8:	d10a      	bne.n	80001d0 <Led_Matrix_init+0x60>
		G_MOSI = PIN_15;
 80001ba:	4b2f      	ldr	r3, [pc, #188]	; (8000278 <Led_Matrix_init+0x108>)
 80001bc:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80001c0:	801a      	strh	r2, [r3, #0]
		G_CLK = PIN_13;
 80001c2:	4b2e      	ldr	r3, [pc, #184]	; (800027c <Led_Matrix_init+0x10c>)
 80001c4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80001c8:	801a      	strh	r2, [r3, #0]
		GPIOx= GPIOB;
 80001ca:	4b2d      	ldr	r3, [pc, #180]	; (8000280 <Led_Matrix_init+0x110>)
 80001cc:	4a2f      	ldr	r2, [pc, #188]	; (800028c <Led_Matrix_init+0x11c>)
 80001ce:	601a      	str	r2, [r3, #0]
	}
	GPIO_PinConfig_t GPIO_pinConfig;
	GPIO_pinConfig.MODE = MODE_OUTPUT_PP;
 80001d0:	2304      	movs	r3, #4
 80001d2:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
	GPIO_pinConfig.Output_Speed = SPEED_10M;
 80001d6:	2301      	movs	r3, #1
 80001d8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	GPIO_pinConfig.Pin_Number = CS_PIN;
 80001dc:	897b      	ldrh	r3, [r7, #10]
 80001de:	85bb      	strh	r3, [r7, #44]	; 0x2c
	GPIO_init(CS_GPIO, &GPIO_pinConfig);
 80001e0:	4b23      	ldr	r3, [pc, #140]	; (8000270 <Led_Matrix_init+0x100>)
 80001e2:	681b      	ldr	r3, [r3, #0]
 80001e4:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80001e8:	4611      	mov	r1, r2
 80001ea:	4618      	mov	r0, r3
 80001ec:	f000 fac8 	bl	8000780 <GPIO_init>
	//SET CS HIGH LEVEL
	GPIO_WritePin(CS_GPIO, CS_PIN, PIN_HIGH);
 80001f0:	4b1f      	ldr	r3, [pc, #124]	; (8000270 <Led_Matrix_init+0x100>)
 80001f2:	681b      	ldr	r3, [r3, #0]
 80001f4:	8979      	ldrh	r1, [r7, #10]
 80001f6:	2201      	movs	r2, #1
 80001f8:	4618      	mov	r0, r3
 80001fa:	f000 fb3d 	bl	8000878 <GPIO_WritePin>
	/* Data bytes on both MOSI and MISO lines are sent with the MSB first. Data on both MOSI
	 and MISO lines must be stable on the rising edge of the clock and can be changed on the
	 falling edge. Data is provided by the MFRC522 on the falling clock edge and is stable
	 during the rising clock edge. */
	SPI_PinConfig_t SPI_pinConfig;
	SPI_pinConfig.Commuincation_Mode = SPI_Direction_2Lines_RXTX;
 80001fe:	2300      	movs	r3, #0
 8000200:	82fb      	strh	r3, [r7, #22]
	SPI_pinConfig.Data_Size = SPI_Data8;
 8000202:	2300      	movs	r3, #0
 8000204:	833b      	strh	r3, [r7, #24]
	SPI_pinConfig.Frame_Format = SPI_Frame_MSB;
 8000206:	2300      	movs	r3, #0
 8000208:	837b      	strh	r3, [r7, #26]
	SPI_pinConfig.BaudRate = SPI_BaudRate_256;
 800020a:	2338      	movs	r3, #56	; 0x38
 800020c:	83bb      	strh	r3, [r7, #28]
	SPI_pinConfig.CLK_Polarity = SPI_CLK_Polarity_0;
 800020e:	2300      	movs	r3, #0
 8000210:	843b      	strh	r3, [r7, #32]
	SPI_pinConfig.CLK_Phase = SPI_CLK_Phase_1st;
 8000212:	2300      	movs	r3, #0
 8000214:	847b      	strh	r3, [r7, #34]	; 0x22
	SPI_pinConfig.SPI_Mode = SPI_Mode_Master;
 8000216:	2304      	movs	r3, #4
 8000218:	82bb      	strh	r3, [r7, #20]
	SPI_pinConfig.NSS = SPI_NSS_Soft_set;
 800021a:	f44f 7340 	mov.w	r3, #768	; 0x300
 800021e:	83fb      	strh	r3, [r7, #30]
	SPI_pinConfig.IRQ_Enable = SPI_IRQ_EN_None;
 8000220:	2300      	movs	r3, #0
 8000222:	84bb      	strh	r3, [r7, #36]	; 0x24
	SPI_pinConfig.P_CallBackFun = NULL;
 8000224:	2300      	movs	r3, #0
 8000226:	62bb      	str	r3, [r7, #40]	; 0x28
	SPI_init(&SPI_pinConfig, SPIx);
 8000228:	f107 0314 	add.w	r3, r7, #20
 800022c:	68f9      	ldr	r1, [r7, #12]
 800022e:	4618      	mov	r0, r3
 8000230:	f000 fcac 	bl	8000b8c <SPI_init>
	SPI_GPIO_SetPins(SPIx);
 8000234:	68f8      	ldr	r0, [r7, #12]
 8000236:	f000 fd51 	bl	8000cdc <SPI_GPIO_SetPins>

	Led_Matrix_write(0x09, 0x00);       //  no decoding
 800023a:	2100      	movs	r1, #0
 800023c:	2009      	movs	r0, #9
 800023e:	f000 f85f 	bl	8000300 <Led_Matrix_write>
	Led_Matrix_write(0x0a, 0x03);       //  brightness intensity
 8000242:	2103      	movs	r1, #3
 8000244:	200a      	movs	r0, #10
 8000246:	f000 f85b 	bl	8000300 <Led_Matrix_write>
	Led_Matrix_write(0x0b, 0x07);       //  scan limit = 8 LEDs
 800024a:	2107      	movs	r1, #7
 800024c:	200b      	movs	r0, #11
 800024e:	f000 f857 	bl	8000300 <Led_Matrix_write>
	Led_Matrix_write(0x0c, 0x01);       //  power down =0,normal mode = 1
 8000252:	2101      	movs	r1, #1
 8000254:	200c      	movs	r0, #12
 8000256:	f000 f853 	bl	8000300 <Led_Matrix_write>
	Led_Matrix_write(0x0f, 0x00);       //  no test display
 800025a:	2100      	movs	r1, #0
 800025c:	200f      	movs	r0, #15
 800025e:	f000 f84f 	bl	8000300 <Led_Matrix_write>

}
 8000262:	bf00      	nop
 8000264:	3730      	adds	r7, #48	; 0x30
 8000266:	46bd      	mov	sp, r7
 8000268:	bd80      	pop	{r7, pc}
 800026a:	bf00      	nop
 800026c:	2000001c 	.word	0x2000001c
 8000270:	20000028 	.word	0x20000028
 8000274:	40013000 	.word	0x40013000
 8000278:	2000001e 	.word	0x2000001e
 800027c:	20000020 	.word	0x20000020
 8000280:	20000024 	.word	0x20000024
 8000284:	40010800 	.word	0x40010800
 8000288:	40003800 	.word	0x40003800
 800028c:	40010c00 	.word	0x40010c00

08000290 <Led_Matrix_writeByte>:
void Led_Matrix_writeByte(uint8 byte) {
 8000290:	b580      	push	{r7, lr}
 8000292:	b084      	sub	sp, #16
 8000294:	af00      	add	r7, sp, #0
 8000296:	4603      	mov	r3, r0
 8000298:	71fb      	strb	r3, [r7, #7]
	for (int i = 0; i < 8; i++) {
 800029a:	2300      	movs	r3, #0
 800029c:	60fb      	str	r3, [r7, #12]
 800029e:	e020      	b.n	80002e2 <Led_Matrix_writeByte+0x52>
		GPIO_WritePin(GPIOx, G_CLK, PIN_LOW);  // pull the clock pin low
 80002a0:	4b14      	ldr	r3, [pc, #80]	; (80002f4 <Led_Matrix_writeByte+0x64>)
 80002a2:	681b      	ldr	r3, [r3, #0]
 80002a4:	4a14      	ldr	r2, [pc, #80]	; (80002f8 <Led_Matrix_writeByte+0x68>)
 80002a6:	8811      	ldrh	r1, [r2, #0]
 80002a8:	2200      	movs	r2, #0
 80002aa:	4618      	mov	r0, r3
 80002ac:	f000 fae4 	bl	8000878 <GPIO_WritePin>
		GPIO_WritePin(GPIOx, G_MOSI, byte & 0x80); // write the MSB bit to the data pin
 80002b0:	4b10      	ldr	r3, [pc, #64]	; (80002f4 <Led_Matrix_writeByte+0x64>)
 80002b2:	6818      	ldr	r0, [r3, #0]
 80002b4:	4b11      	ldr	r3, [pc, #68]	; (80002fc <Led_Matrix_writeByte+0x6c>)
 80002b6:	8819      	ldrh	r1, [r3, #0]
 80002b8:	79fb      	ldrb	r3, [r7, #7]
 80002ba:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80002be:	b2db      	uxtb	r3, r3
 80002c0:	461a      	mov	r2, r3
 80002c2:	f000 fad9 	bl	8000878 <GPIO_WritePin>
		byte = byte << 1;  // shift left
 80002c6:	79fb      	ldrb	r3, [r7, #7]
 80002c8:	005b      	lsls	r3, r3, #1
 80002ca:	71fb      	strb	r3, [r7, #7]
		GPIO_WritePin(GPIOx, G_CLK, PIN_HIGH);  // pull the clock pin HIGH
 80002cc:	4b09      	ldr	r3, [pc, #36]	; (80002f4 <Led_Matrix_writeByte+0x64>)
 80002ce:	681b      	ldr	r3, [r3, #0]
 80002d0:	4a09      	ldr	r2, [pc, #36]	; (80002f8 <Led_Matrix_writeByte+0x68>)
 80002d2:	8811      	ldrh	r1, [r2, #0]
 80002d4:	2201      	movs	r2, #1
 80002d6:	4618      	mov	r0, r3
 80002d8:	f000 face 	bl	8000878 <GPIO_WritePin>
	for (int i = 0; i < 8; i++) {
 80002dc:	68fb      	ldr	r3, [r7, #12]
 80002de:	3301      	adds	r3, #1
 80002e0:	60fb      	str	r3, [r7, #12]
 80002e2:	68fb      	ldr	r3, [r7, #12]
 80002e4:	2b07      	cmp	r3, #7
 80002e6:	dddb      	ble.n	80002a0 <Led_Matrix_writeByte+0x10>
	}
}
 80002e8:	bf00      	nop
 80002ea:	bf00      	nop
 80002ec:	3710      	adds	r7, #16
 80002ee:	46bd      	mov	sp, r7
 80002f0:	bd80      	pop	{r7, pc}
 80002f2:	bf00      	nop
 80002f4:	20000024 	.word	0x20000024
 80002f8:	20000020 	.word	0x20000020
 80002fc:	2000001e 	.word	0x2000001e

08000300 <Led_Matrix_write>:
void Led_Matrix_write(uint8 address, uint8 data) {
 8000300:	b580      	push	{r7, lr}
 8000302:	b082      	sub	sp, #8
 8000304:	af00      	add	r7, sp, #0
 8000306:	4603      	mov	r3, r0
 8000308:	460a      	mov	r2, r1
 800030a:	71fb      	strb	r3, [r7, #7]
 800030c:	4613      	mov	r3, r2
 800030e:	71bb      	strb	r3, [r7, #6]
	GPIO_WritePin(CS_GPIO, G_CS, PIN_LOW);  // pull the CS pin LOW
 8000310:	4b0d      	ldr	r3, [pc, #52]	; (8000348 <Led_Matrix_write+0x48>)
 8000312:	681b      	ldr	r3, [r3, #0]
 8000314:	4a0d      	ldr	r2, [pc, #52]	; (800034c <Led_Matrix_write+0x4c>)
 8000316:	8811      	ldrh	r1, [r2, #0]
 8000318:	2200      	movs	r2, #0
 800031a:	4618      	mov	r0, r3
 800031c:	f000 faac 	bl	8000878 <GPIO_WritePin>
	Led_Matrix_writeByte(address);
 8000320:	79fb      	ldrb	r3, [r7, #7]
 8000322:	4618      	mov	r0, r3
 8000324:	f7ff ffb4 	bl	8000290 <Led_Matrix_writeByte>
	Led_Matrix_writeByte(data);
 8000328:	79bb      	ldrb	r3, [r7, #6]
 800032a:	4618      	mov	r0, r3
 800032c:	f7ff ffb0 	bl	8000290 <Led_Matrix_writeByte>
	GPIO_WritePin(CS_GPIO, G_CS, PIN_HIGH);  // pull the CS pin HIGH
 8000330:	4b05      	ldr	r3, [pc, #20]	; (8000348 <Led_Matrix_write+0x48>)
 8000332:	681b      	ldr	r3, [r3, #0]
 8000334:	4a05      	ldr	r2, [pc, #20]	; (800034c <Led_Matrix_write+0x4c>)
 8000336:	8811      	ldrh	r1, [r2, #0]
 8000338:	2201      	movs	r2, #1
 800033a:	4618      	mov	r0, r3
 800033c:	f000 fa9c 	bl	8000878 <GPIO_WritePin>
}
 8000340:	bf00      	nop
 8000342:	3708      	adds	r7, #8
 8000344:	46bd      	mov	sp, r7
 8000346:	bd80      	pop	{r7, pc}
 8000348:	20000028 	.word	0x20000028
 800034c:	2000001c 	.word	0x2000001c

08000350 <Led_Matrix_writeString>:
void Led_Matrix_writeString(char *str) {
 8000350:	b580      	push	{r7, lr}
 8000352:	b084      	sub	sp, #16
 8000354:	af00      	add	r7, sp, #0
 8000356:	6078      	str	r0, [r7, #4]
	while (*str) {
 8000358:	e01f      	b.n	800039a <Led_Matrix_writeString+0x4a>
		for (int i = 1; i < 9; i++) {
 800035a:	2301      	movs	r3, #1
 800035c:	60fb      	str	r3, [r7, #12]
 800035e:	e012      	b.n	8000386 <Led_Matrix_writeString+0x36>
			Led_Matrix_write(i, display[(*str - 48)][i - 1]);
 8000360:	68fb      	ldr	r3, [r7, #12]
 8000362:	b2d8      	uxtb	r0, r3
 8000364:	687b      	ldr	r3, [r7, #4]
 8000366:	781b      	ldrb	r3, [r3, #0]
 8000368:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800036c:	68fb      	ldr	r3, [r7, #12]
 800036e:	3b01      	subs	r3, #1
 8000370:	490e      	ldr	r1, [pc, #56]	; (80003ac <Led_Matrix_writeString+0x5c>)
 8000372:	00d2      	lsls	r2, r2, #3
 8000374:	440a      	add	r2, r1
 8000376:	4413      	add	r3, r2
 8000378:	781b      	ldrb	r3, [r3, #0]
 800037a:	4619      	mov	r1, r3
 800037c:	f7ff ffc0 	bl	8000300 <Led_Matrix_write>
		for (int i = 1; i < 9; i++) {
 8000380:	68fb      	ldr	r3, [r7, #12]
 8000382:	3301      	adds	r3, #1
 8000384:	60fb      	str	r3, [r7, #12]
 8000386:	68fb      	ldr	r3, [r7, #12]
 8000388:	2b08      	cmp	r3, #8
 800038a:	dde9      	ble.n	8000360 <Led_Matrix_writeString+0x10>
		}
		*str++;
 800038c:	687b      	ldr	r3, [r7, #4]
 800038e:	3301      	adds	r3, #1
 8000390:	607b      	str	r3, [r7, #4]
		STK_delayMs(20000);
 8000392:	f644 6020 	movw	r0, #20000	; 0x4e20
 8000396:	f000 fdfd 	bl	8000f94 <STK_delayMs>
	while (*str) {
 800039a:	687b      	ldr	r3, [r7, #4]
 800039c:	781b      	ldrb	r3, [r3, #0]
 800039e:	2b00      	cmp	r3, #0
 80003a0:	d1db      	bne.n	800035a <Led_Matrix_writeString+0xa>
	}
}
 80003a2:	bf00      	nop
 80003a4:	bf00      	nop
 80003a6:	3710      	adds	r7, #16
 80003a8:	46bd      	mov	sp, r7
 80003aa:	bd80      	pop	{r7, pc}
 80003ac:	08001184 	.word	0x08001184

080003b0 <EXTI0_IRQHandler>:
//=================================
void (*GP_Fun[16])(void);
//=================================
//       IRQ Handlers
//=================================
void EXTI0_IRQHandler() {
 80003b0:	b580      	push	{r7, lr}
 80003b2:	af00      	add	r7, sp, #0
	EXTI->PR |= (1 << 0);
 80003b4:	4b05      	ldr	r3, [pc, #20]	; (80003cc <EXTI0_IRQHandler+0x1c>)
 80003b6:	695b      	ldr	r3, [r3, #20]
 80003b8:	4a04      	ldr	r2, [pc, #16]	; (80003cc <EXTI0_IRQHandler+0x1c>)
 80003ba:	f043 0301 	orr.w	r3, r3, #1
 80003be:	6153      	str	r3, [r2, #20]
	GP_Fun[0]();
 80003c0:	4b03      	ldr	r3, [pc, #12]	; (80003d0 <EXTI0_IRQHandler+0x20>)
 80003c2:	681b      	ldr	r3, [r3, #0]
 80003c4:	4798      	blx	r3
}
 80003c6:	bf00      	nop
 80003c8:	bd80      	pop	{r7, pc}
 80003ca:	bf00      	nop
 80003cc:	40010400 	.word	0x40010400
 80003d0:	2000002c 	.word	0x2000002c

080003d4 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler() {
 80003d4:	b580      	push	{r7, lr}
 80003d6:	af00      	add	r7, sp, #0
	EXTI->PR |= (1 << 1);
 80003d8:	4b05      	ldr	r3, [pc, #20]	; (80003f0 <EXTI1_IRQHandler+0x1c>)
 80003da:	695b      	ldr	r3, [r3, #20]
 80003dc:	4a04      	ldr	r2, [pc, #16]	; (80003f0 <EXTI1_IRQHandler+0x1c>)
 80003de:	f043 0302 	orr.w	r3, r3, #2
 80003e2:	6153      	str	r3, [r2, #20]
	GP_Fun[1]();
 80003e4:	4b03      	ldr	r3, [pc, #12]	; (80003f4 <EXTI1_IRQHandler+0x20>)
 80003e6:	685b      	ldr	r3, [r3, #4]
 80003e8:	4798      	blx	r3
}
 80003ea:	bf00      	nop
 80003ec:	bd80      	pop	{r7, pc}
 80003ee:	bf00      	nop
 80003f0:	40010400 	.word	0x40010400
 80003f4:	2000002c 	.word	0x2000002c

080003f8 <EXTI2_IRQHandler>:
void EXTI2_IRQHandler() {
 80003f8:	b580      	push	{r7, lr}
 80003fa:	af00      	add	r7, sp, #0
	EXTI->PR |= (1 << 2);
 80003fc:	4b05      	ldr	r3, [pc, #20]	; (8000414 <EXTI2_IRQHandler+0x1c>)
 80003fe:	695b      	ldr	r3, [r3, #20]
 8000400:	4a04      	ldr	r2, [pc, #16]	; (8000414 <EXTI2_IRQHandler+0x1c>)
 8000402:	f043 0304 	orr.w	r3, r3, #4
 8000406:	6153      	str	r3, [r2, #20]
	GP_Fun[2]();
 8000408:	4b03      	ldr	r3, [pc, #12]	; (8000418 <EXTI2_IRQHandler+0x20>)
 800040a:	689b      	ldr	r3, [r3, #8]
 800040c:	4798      	blx	r3
}
 800040e:	bf00      	nop
 8000410:	bd80      	pop	{r7, pc}
 8000412:	bf00      	nop
 8000414:	40010400 	.word	0x40010400
 8000418:	2000002c 	.word	0x2000002c

0800041c <EXTI3_IRQHandler>:
void EXTI3_IRQHandler() {
 800041c:	b580      	push	{r7, lr}
 800041e:	af00      	add	r7, sp, #0
	EXTI->PR |= (1 << 3);
 8000420:	4b05      	ldr	r3, [pc, #20]	; (8000438 <EXTI3_IRQHandler+0x1c>)
 8000422:	695b      	ldr	r3, [r3, #20]
 8000424:	4a04      	ldr	r2, [pc, #16]	; (8000438 <EXTI3_IRQHandler+0x1c>)
 8000426:	f043 0308 	orr.w	r3, r3, #8
 800042a:	6153      	str	r3, [r2, #20]
	GP_Fun[3]();
 800042c:	4b03      	ldr	r3, [pc, #12]	; (800043c <EXTI3_IRQHandler+0x20>)
 800042e:	68db      	ldr	r3, [r3, #12]
 8000430:	4798      	blx	r3
}
 8000432:	bf00      	nop
 8000434:	bd80      	pop	{r7, pc}
 8000436:	bf00      	nop
 8000438:	40010400 	.word	0x40010400
 800043c:	2000002c 	.word	0x2000002c

08000440 <EXTI4_IRQHandler>:
void EXTI4_IRQHandler() {
 8000440:	b580      	push	{r7, lr}
 8000442:	af00      	add	r7, sp, #0
	EXTI->PR |= (1 << 4);
 8000444:	4b05      	ldr	r3, [pc, #20]	; (800045c <EXTI4_IRQHandler+0x1c>)
 8000446:	695b      	ldr	r3, [r3, #20]
 8000448:	4a04      	ldr	r2, [pc, #16]	; (800045c <EXTI4_IRQHandler+0x1c>)
 800044a:	f043 0310 	orr.w	r3, r3, #16
 800044e:	6153      	str	r3, [r2, #20]
	GP_Fun[4]();
 8000450:	4b03      	ldr	r3, [pc, #12]	; (8000460 <EXTI4_IRQHandler+0x20>)
 8000452:	691b      	ldr	r3, [r3, #16]
 8000454:	4798      	blx	r3
}
 8000456:	bf00      	nop
 8000458:	bd80      	pop	{r7, pc}
 800045a:	bf00      	nop
 800045c:	40010400 	.word	0x40010400
 8000460:	2000002c 	.word	0x2000002c

08000464 <EXTI9_5_IRQHandler>:
void EXTI9_5_IRQHandler() {
 8000464:	b580      	push	{r7, lr}
 8000466:	af00      	add	r7, sp, #0
	if (EXTI->PR & (1 << 5)) {
 8000468:	4b28      	ldr	r3, [pc, #160]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 800046a:	695b      	ldr	r3, [r3, #20]
 800046c:	f003 0320 	and.w	r3, r3, #32
 8000470:	2b00      	cmp	r3, #0
 8000472:	d009      	beq.n	8000488 <EXTI9_5_IRQHandler+0x24>
		EXTI->PR |= (1 << 5);
 8000474:	4b25      	ldr	r3, [pc, #148]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 8000476:	695b      	ldr	r3, [r3, #20]
 8000478:	4a24      	ldr	r2, [pc, #144]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 800047a:	f043 0320 	orr.w	r3, r3, #32
 800047e:	6153      	str	r3, [r2, #20]
		GP_Fun[5]();
 8000480:	4b23      	ldr	r3, [pc, #140]	; (8000510 <EXTI9_5_IRQHandler+0xac>)
 8000482:	695b      	ldr	r3, [r3, #20]
 8000484:	4798      	blx	r3
		GP_Fun[8]();
	} else if (EXTI->PR & (1 << 9)) {
		EXTI->PR |= (1 << 9);
		GP_Fun[9]();
	}
}
 8000486:	e03e      	b.n	8000506 <EXTI9_5_IRQHandler+0xa2>
	} else if (EXTI->PR & (1 << 6)) {
 8000488:	4b20      	ldr	r3, [pc, #128]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 800048a:	695b      	ldr	r3, [r3, #20]
 800048c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000490:	2b00      	cmp	r3, #0
 8000492:	d009      	beq.n	80004a8 <EXTI9_5_IRQHandler+0x44>
		EXTI->PR |= (1 << 6);
 8000494:	4b1d      	ldr	r3, [pc, #116]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 8000496:	695b      	ldr	r3, [r3, #20]
 8000498:	4a1c      	ldr	r2, [pc, #112]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 800049a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800049e:	6153      	str	r3, [r2, #20]
		GP_Fun[6]();
 80004a0:	4b1b      	ldr	r3, [pc, #108]	; (8000510 <EXTI9_5_IRQHandler+0xac>)
 80004a2:	699b      	ldr	r3, [r3, #24]
 80004a4:	4798      	blx	r3
}
 80004a6:	e02e      	b.n	8000506 <EXTI9_5_IRQHandler+0xa2>
	} else if (EXTI->PR & (1 << 7)) {
 80004a8:	4b18      	ldr	r3, [pc, #96]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004aa:	695b      	ldr	r3, [r3, #20]
 80004ac:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80004b0:	2b00      	cmp	r3, #0
 80004b2:	d009      	beq.n	80004c8 <EXTI9_5_IRQHandler+0x64>
		EXTI->PR |= (1 << 7);
 80004b4:	4b15      	ldr	r3, [pc, #84]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004b6:	695b      	ldr	r3, [r3, #20]
 80004b8:	4a14      	ldr	r2, [pc, #80]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004ba:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80004be:	6153      	str	r3, [r2, #20]
		GP_Fun[7]();
 80004c0:	4b13      	ldr	r3, [pc, #76]	; (8000510 <EXTI9_5_IRQHandler+0xac>)
 80004c2:	69db      	ldr	r3, [r3, #28]
 80004c4:	4798      	blx	r3
}
 80004c6:	e01e      	b.n	8000506 <EXTI9_5_IRQHandler+0xa2>
	} else if (EXTI->PR & (1 << 8)) {
 80004c8:	4b10      	ldr	r3, [pc, #64]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004ca:	695b      	ldr	r3, [r3, #20]
 80004cc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80004d0:	2b00      	cmp	r3, #0
 80004d2:	d009      	beq.n	80004e8 <EXTI9_5_IRQHandler+0x84>
		EXTI->PR |= (1 << 8);
 80004d4:	4b0d      	ldr	r3, [pc, #52]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004d6:	695b      	ldr	r3, [r3, #20]
 80004d8:	4a0c      	ldr	r2, [pc, #48]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004da:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80004de:	6153      	str	r3, [r2, #20]
		GP_Fun[8]();
 80004e0:	4b0b      	ldr	r3, [pc, #44]	; (8000510 <EXTI9_5_IRQHandler+0xac>)
 80004e2:	6a1b      	ldr	r3, [r3, #32]
 80004e4:	4798      	blx	r3
}
 80004e6:	e00e      	b.n	8000506 <EXTI9_5_IRQHandler+0xa2>
	} else if (EXTI->PR & (1 << 9)) {
 80004e8:	4b08      	ldr	r3, [pc, #32]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004ea:	695b      	ldr	r3, [r3, #20]
 80004ec:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80004f0:	2b00      	cmp	r3, #0
 80004f2:	d008      	beq.n	8000506 <EXTI9_5_IRQHandler+0xa2>
		EXTI->PR |= (1 << 9);
 80004f4:	4b05      	ldr	r3, [pc, #20]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004f6:	695b      	ldr	r3, [r3, #20]
 80004f8:	4a04      	ldr	r2, [pc, #16]	; (800050c <EXTI9_5_IRQHandler+0xa8>)
 80004fa:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80004fe:	6153      	str	r3, [r2, #20]
		GP_Fun[9]();
 8000500:	4b03      	ldr	r3, [pc, #12]	; (8000510 <EXTI9_5_IRQHandler+0xac>)
 8000502:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000504:	4798      	blx	r3
}
 8000506:	bf00      	nop
 8000508:	bd80      	pop	{r7, pc}
 800050a:	bf00      	nop
 800050c:	40010400 	.word	0x40010400
 8000510:	2000002c 	.word	0x2000002c

08000514 <EXTI15_10_IRQHandler>:
void EXTI15_10_IRQHandler() {
 8000514:	b580      	push	{r7, lr}
 8000516:	af00      	add	r7, sp, #0
	if (EXTI->PR & (1 << 10)) {
 8000518:	4b30      	ldr	r3, [pc, #192]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800051a:	695b      	ldr	r3, [r3, #20]
 800051c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8000520:	2b00      	cmp	r3, #0
 8000522:	d009      	beq.n	8000538 <EXTI15_10_IRQHandler+0x24>
		EXTI->PR |= (1 << 10);
 8000524:	4b2d      	ldr	r3, [pc, #180]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 8000526:	695b      	ldr	r3, [r3, #20]
 8000528:	4a2c      	ldr	r2, [pc, #176]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800052a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800052e:	6153      	str	r3, [r2, #20]
		GP_Fun[10]();
 8000530:	4b2b      	ldr	r3, [pc, #172]	; (80005e0 <EXTI15_10_IRQHandler+0xcc>)
 8000532:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000534:	4798      	blx	r3
	} else if (EXTI->PR & (1 << 15)) {
		EXTI->PR |= (1 << 15);
		GP_Fun[15]();
	}

}
 8000536:	e04e      	b.n	80005d6 <EXTI15_10_IRQHandler+0xc2>
	} else if (EXTI->PR & (1 << 11)) {
 8000538:	4b28      	ldr	r3, [pc, #160]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800053a:	695b      	ldr	r3, [r3, #20]
 800053c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000540:	2b00      	cmp	r3, #0
 8000542:	d009      	beq.n	8000558 <EXTI15_10_IRQHandler+0x44>
		EXTI->PR |= (1 << 11);
 8000544:	4b25      	ldr	r3, [pc, #148]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 8000546:	695b      	ldr	r3, [r3, #20]
 8000548:	4a24      	ldr	r2, [pc, #144]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800054a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800054e:	6153      	str	r3, [r2, #20]
		GP_Fun[11]();
 8000550:	4b23      	ldr	r3, [pc, #140]	; (80005e0 <EXTI15_10_IRQHandler+0xcc>)
 8000552:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000554:	4798      	blx	r3
}
 8000556:	e03e      	b.n	80005d6 <EXTI15_10_IRQHandler+0xc2>
	} else if (EXTI->PR & (1 << 12)) {
 8000558:	4b20      	ldr	r3, [pc, #128]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800055a:	695b      	ldr	r3, [r3, #20]
 800055c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000560:	2b00      	cmp	r3, #0
 8000562:	d009      	beq.n	8000578 <EXTI15_10_IRQHandler+0x64>
		EXTI->PR |= (1 << 12);
 8000564:	4b1d      	ldr	r3, [pc, #116]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 8000566:	695b      	ldr	r3, [r3, #20]
 8000568:	4a1c      	ldr	r2, [pc, #112]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800056a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800056e:	6153      	str	r3, [r2, #20]
		GP_Fun[12]();
 8000570:	4b1b      	ldr	r3, [pc, #108]	; (80005e0 <EXTI15_10_IRQHandler+0xcc>)
 8000572:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000574:	4798      	blx	r3
}
 8000576:	e02e      	b.n	80005d6 <EXTI15_10_IRQHandler+0xc2>
	} else if (EXTI->PR & (1 << 13)) {
 8000578:	4b18      	ldr	r3, [pc, #96]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800057a:	695b      	ldr	r3, [r3, #20]
 800057c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000580:	2b00      	cmp	r3, #0
 8000582:	d009      	beq.n	8000598 <EXTI15_10_IRQHandler+0x84>
		EXTI->PR |= (1 << 13);
 8000584:	4b15      	ldr	r3, [pc, #84]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 8000586:	695b      	ldr	r3, [r3, #20]
 8000588:	4a14      	ldr	r2, [pc, #80]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800058a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800058e:	6153      	str	r3, [r2, #20]
		GP_Fun[13]();
 8000590:	4b13      	ldr	r3, [pc, #76]	; (80005e0 <EXTI15_10_IRQHandler+0xcc>)
 8000592:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000594:	4798      	blx	r3
}
 8000596:	e01e      	b.n	80005d6 <EXTI15_10_IRQHandler+0xc2>
	} else if (EXTI->PR & (1 << 14)) {
 8000598:	4b10      	ldr	r3, [pc, #64]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 800059a:	695b      	ldr	r3, [r3, #20]
 800059c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80005a0:	2b00      	cmp	r3, #0
 80005a2:	d009      	beq.n	80005b8 <EXTI15_10_IRQHandler+0xa4>
		EXTI->PR |= (1 << 14);
 80005a4:	4b0d      	ldr	r3, [pc, #52]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 80005a6:	695b      	ldr	r3, [r3, #20]
 80005a8:	4a0c      	ldr	r2, [pc, #48]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 80005aa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80005ae:	6153      	str	r3, [r2, #20]
		GP_Fun[14]();
 80005b0:	4b0b      	ldr	r3, [pc, #44]	; (80005e0 <EXTI15_10_IRQHandler+0xcc>)
 80005b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80005b4:	4798      	blx	r3
}
 80005b6:	e00e      	b.n	80005d6 <EXTI15_10_IRQHandler+0xc2>
	} else if (EXTI->PR & (1 << 15)) {
 80005b8:	4b08      	ldr	r3, [pc, #32]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 80005ba:	695b      	ldr	r3, [r3, #20]
 80005bc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80005c0:	2b00      	cmp	r3, #0
 80005c2:	d008      	beq.n	80005d6 <EXTI15_10_IRQHandler+0xc2>
		EXTI->PR |= (1 << 15);
 80005c4:	4b05      	ldr	r3, [pc, #20]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 80005c6:	695b      	ldr	r3, [r3, #20]
 80005c8:	4a04      	ldr	r2, [pc, #16]	; (80005dc <EXTI15_10_IRQHandler+0xc8>)
 80005ca:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80005ce:	6153      	str	r3, [r2, #20]
		GP_Fun[15]();
 80005d0:	4b03      	ldr	r3, [pc, #12]	; (80005e0 <EXTI15_10_IRQHandler+0xcc>)
 80005d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80005d4:	4798      	blx	r3
}
 80005d6:	bf00      	nop
 80005d8:	bd80      	pop	{r7, pc}
 80005da:	bf00      	nop
 80005dc:	40010400 	.word	0x40010400
 80005e0:	2000002c 	.word	0x2000002c

080005e4 <Get_CRLH_Position>:
 *      Author: Alaa Wahba
 */

#include "GPIO.h"

uint8 Get_CRLH_Position(uint16 pinNumber) {
 80005e4:	b480      	push	{r7}
 80005e6:	b085      	sub	sp, #20
 80005e8:	af00      	add	r7, sp, #0
 80005ea:	4603      	mov	r3, r0
 80005ec:	80fb      	strh	r3, [r7, #6]
	uint8 shift = 0;
 80005ee:	2300      	movs	r3, #0
 80005f0:	73fb      	strb	r3, [r7, #15]
	switch (pinNumber) {
 80005f2:	88fb      	ldrh	r3, [r7, #6]
 80005f4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80005f8:	f000 80b8 	beq.w	800076c <Get_CRLH_Position+0x188>
 80005fc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8000600:	f300 80b7 	bgt.w	8000772 <Get_CRLH_Position+0x18e>
 8000604:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8000608:	f000 80ad 	beq.w	8000766 <Get_CRLH_Position+0x182>
 800060c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8000610:	f300 80af 	bgt.w	8000772 <Get_CRLH_Position+0x18e>
 8000614:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8000618:	f000 80a2 	beq.w	8000760 <Get_CRLH_Position+0x17c>
 800061c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8000620:	f300 80a7 	bgt.w	8000772 <Get_CRLH_Position+0x18e>
 8000624:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8000628:	f000 8097 	beq.w	800075a <Get_CRLH_Position+0x176>
 800062c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8000630:	f300 809f 	bgt.w	8000772 <Get_CRLH_Position+0x18e>
 8000634:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8000638:	f000 808c 	beq.w	8000754 <Get_CRLH_Position+0x170>
 800063c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8000640:	f300 8097 	bgt.w	8000772 <Get_CRLH_Position+0x18e>
 8000644:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000648:	f000 8081 	beq.w	800074e <Get_CRLH_Position+0x16a>
 800064c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000650:	f300 808f 	bgt.w	8000772 <Get_CRLH_Position+0x18e>
 8000654:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000658:	d076      	beq.n	8000748 <Get_CRLH_Position+0x164>
 800065a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800065e:	f300 8088 	bgt.w	8000772 <Get_CRLH_Position+0x18e>
 8000662:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000666:	d06c      	beq.n	8000742 <Get_CRLH_Position+0x15e>
 8000668:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800066c:	f300 8081 	bgt.w	8000772 <Get_CRLH_Position+0x18e>
 8000670:	2b80      	cmp	r3, #128	; 0x80
 8000672:	d063      	beq.n	800073c <Get_CRLH_Position+0x158>
 8000674:	2b80      	cmp	r3, #128	; 0x80
 8000676:	dc7c      	bgt.n	8000772 <Get_CRLH_Position+0x18e>
 8000678:	2b20      	cmp	r3, #32
 800067a:	dc47      	bgt.n	800070c <Get_CRLH_Position+0x128>
 800067c:	2b00      	cmp	r3, #0
 800067e:	dd78      	ble.n	8000772 <Get_CRLH_Position+0x18e>
 8000680:	3b01      	subs	r3, #1
 8000682:	2b1f      	cmp	r3, #31
 8000684:	d875      	bhi.n	8000772 <Get_CRLH_Position+0x18e>
 8000686:	a201      	add	r2, pc, #4	; (adr r2, 800068c <Get_CRLH_Position+0xa8>)
 8000688:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800068c:	08000713 	.word	0x08000713
 8000690:	08000719 	.word	0x08000719
 8000694:	08000773 	.word	0x08000773
 8000698:	0800071f 	.word	0x0800071f
 800069c:	08000773 	.word	0x08000773
 80006a0:	08000773 	.word	0x08000773
 80006a4:	08000773 	.word	0x08000773
 80006a8:	08000725 	.word	0x08000725
 80006ac:	08000773 	.word	0x08000773
 80006b0:	08000773 	.word	0x08000773
 80006b4:	08000773 	.word	0x08000773
 80006b8:	08000773 	.word	0x08000773
 80006bc:	08000773 	.word	0x08000773
 80006c0:	08000773 	.word	0x08000773
 80006c4:	08000773 	.word	0x08000773
 80006c8:	0800072b 	.word	0x0800072b
 80006cc:	08000773 	.word	0x08000773
 80006d0:	08000773 	.word	0x08000773
 80006d4:	08000773 	.word	0x08000773
 80006d8:	08000773 	.word	0x08000773
 80006dc:	08000773 	.word	0x08000773
 80006e0:	08000773 	.word	0x08000773
 80006e4:	08000773 	.word	0x08000773
 80006e8:	08000773 	.word	0x08000773
 80006ec:	08000773 	.word	0x08000773
 80006f0:	08000773 	.word	0x08000773
 80006f4:	08000773 	.word	0x08000773
 80006f8:	08000773 	.word	0x08000773
 80006fc:	08000773 	.word	0x08000773
 8000700:	08000773 	.word	0x08000773
 8000704:	08000773 	.word	0x08000773
 8000708:	08000731 	.word	0x08000731
 800070c:	2b40      	cmp	r3, #64	; 0x40
 800070e:	d012      	beq.n	8000736 <Get_CRLH_Position+0x152>
 8000710:	e02f      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_0:
		shift = 0;
 8000712:	2300      	movs	r3, #0
 8000714:	73fb      	strb	r3, [r7, #15]
		break;
 8000716:	e02c      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_1:
		shift = 4;
 8000718:	2304      	movs	r3, #4
 800071a:	73fb      	strb	r3, [r7, #15]
		break;
 800071c:	e029      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_2:
		shift = 8;
 800071e:	2308      	movs	r3, #8
 8000720:	73fb      	strb	r3, [r7, #15]
		break;
 8000722:	e026      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_3:
		shift = 12;
 8000724:	230c      	movs	r3, #12
 8000726:	73fb      	strb	r3, [r7, #15]
		break;
 8000728:	e023      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_4:
		shift = 16;
 800072a:	2310      	movs	r3, #16
 800072c:	73fb      	strb	r3, [r7, #15]
		break;
 800072e:	e020      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_5:
		shift = 20;
 8000730:	2314      	movs	r3, #20
 8000732:	73fb      	strb	r3, [r7, #15]
		break;
 8000734:	e01d      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_6:
		shift = 24;
 8000736:	2318      	movs	r3, #24
 8000738:	73fb      	strb	r3, [r7, #15]
		break;
 800073a:	e01a      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_7:
		shift = 28;
 800073c:	231c      	movs	r3, #28
 800073e:	73fb      	strb	r3, [r7, #15]
		break;
 8000740:	e017      	b.n	8000772 <Get_CRLH_Position+0x18e>

	case PIN_8:
		shift = 0;
 8000742:	2300      	movs	r3, #0
 8000744:	73fb      	strb	r3, [r7, #15]
		break;
 8000746:	e014      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_9:
		shift = 4;
 8000748:	2304      	movs	r3, #4
 800074a:	73fb      	strb	r3, [r7, #15]
		break;
 800074c:	e011      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_10:
		shift = 8;
 800074e:	2308      	movs	r3, #8
 8000750:	73fb      	strb	r3, [r7, #15]
		break;
 8000752:	e00e      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_11:
		shift = 12;
 8000754:	230c      	movs	r3, #12
 8000756:	73fb      	strb	r3, [r7, #15]
		break;
 8000758:	e00b      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_12:
		shift = 16;
 800075a:	2310      	movs	r3, #16
 800075c:	73fb      	strb	r3, [r7, #15]
		break;
 800075e:	e008      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_13:
		shift = 20;
 8000760:	2314      	movs	r3, #20
 8000762:	73fb      	strb	r3, [r7, #15]
		break;
 8000764:	e005      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_14:
		shift = 24;
 8000766:	2318      	movs	r3, #24
 8000768:	73fb      	strb	r3, [r7, #15]
		break;
 800076a:	e002      	b.n	8000772 <Get_CRLH_Position+0x18e>
	case PIN_15:
		shift = 28;
 800076c:	231c      	movs	r3, #28
 800076e:	73fb      	strb	r3, [r7, #15]
		break;
 8000770:	bf00      	nop

	}
	return shift;
 8000772:	7bfb      	ldrb	r3, [r7, #15]
}
 8000774:	4618      	mov	r0, r3
 8000776:	3714      	adds	r7, #20
 8000778:	46bd      	mov	sp, r7
 800077a:	bc80      	pop	{r7}
 800077c:	4770      	bx	lr
 800077e:	bf00      	nop

08000780 <GPIO_init>:
 * @retval 			- none
 * Note				- Stm32F103C6 MCU has GPIO A,B,C,D,E Modules
 * 				     But LQFP48 Package has only GPIO A,B,PART of C/D exported as external PINS from the MCU
 */

void GPIO_init(GPIO_Registers_t *GPIOx, GPIO_PinConfig_t *pinConfig) {
 8000780:	b580      	push	{r7, lr}
 8000782:	b086      	sub	sp, #24
 8000784:	af00      	add	r7, sp, #0
 8000786:	6078      	str	r0, [r7, #4]
 8000788:	6039      	str	r1, [r7, #0]
	// CRL configures the pins from pin 0 to 7
	// CRH configures the pins from pin 8 to 15
	volatile uint32 *config_Register = NULL; //this pointer determines which register to use
 800078a:	2300      	movs	r3, #0
 800078c:	613b      	str	r3, [r7, #16]
	config_Register = (pinConfig->Pin_Number < PIN_8) ? &GPIOx->CRL : &GPIOx->CRH;
 800078e:	683b      	ldr	r3, [r7, #0]
 8000790:	881b      	ldrh	r3, [r3, #0]
 8000792:	2bff      	cmp	r3, #255	; 0xff
 8000794:	d801      	bhi.n	800079a <GPIO_init+0x1a>
 8000796:	687b      	ldr	r3, [r7, #4]
 8000798:	e001      	b.n	800079e <GPIO_init+0x1e>
 800079a:	687b      	ldr	r3, [r7, #4]
 800079c:	3304      	adds	r3, #4
 800079e:	613b      	str	r3, [r7, #16]

	// This returns the starting bit in register CRL/CRH for the specified pin.
	uint8 shift_bit = Get_CRLH_Position(pinConfig->Pin_Number);
 80007a0:	683b      	ldr	r3, [r7, #0]
 80007a2:	881b      	ldrh	r3, [r3, #0]
 80007a4:	4618      	mov	r0, r3
 80007a6:	f7ff ff1d 	bl	80005e4 <Get_CRLH_Position>
 80007aa:	4603      	mov	r3, r0
 80007ac:	73fb      	strb	r3, [r7, #15]

	// First Clear the CNF[1:0] MODE[1:0]
	(*config_Register) &= ~(0xF << shift_bit);
 80007ae:	693b      	ldr	r3, [r7, #16]
 80007b0:	681b      	ldr	r3, [r3, #0]
 80007b2:	7bfa      	ldrb	r2, [r7, #15]
 80007b4:	210f      	movs	r1, #15
 80007b6:	fa01 f202 	lsl.w	r2, r1, r2
 80007ba:	43d2      	mvns	r2, r2
 80007bc:	401a      	ands	r2, r3
 80007be:	693b      	ldr	r3, [r7, #16]
 80007c0:	601a      	str	r2, [r3, #0]

	uint8 register_bits = 0;
 80007c2:	2300      	movs	r3, #0
 80007c4:	75fb      	strb	r3, [r7, #23]
	// if pin is OUTPUT
	if ((pinConfig->MODE == MODE_OUTPUT_AF_OD) || (pinConfig->MODE == MODE_OUTPUT_AF_PP) || (pinConfig->MODE == MODE_OUTPUT_PP)	|| (pinConfig->MODE == MODE_OUTPUT_OD)) {
 80007c6:	683b      	ldr	r3, [r7, #0]
 80007c8:	789b      	ldrb	r3, [r3, #2]
 80007ca:	2b07      	cmp	r3, #7
 80007cc:	d00b      	beq.n	80007e6 <GPIO_init+0x66>
 80007ce:	683b      	ldr	r3, [r7, #0]
 80007d0:	789b      	ldrb	r3, [r3, #2]
 80007d2:	2b06      	cmp	r3, #6
 80007d4:	d007      	beq.n	80007e6 <GPIO_init+0x66>
 80007d6:	683b      	ldr	r3, [r7, #0]
 80007d8:	789b      	ldrb	r3, [r3, #2]
 80007da:	2b04      	cmp	r3, #4
 80007dc:	d003      	beq.n	80007e6 <GPIO_init+0x66>
 80007de:	683b      	ldr	r3, [r7, #0]
 80007e0:	789b      	ldrb	r3, [r3, #2]
 80007e2:	2b05      	cmp	r3, #5
 80007e4:	d10e      	bne.n	8000804 <GPIO_init+0x84>
		register_bits = ((((pinConfig->MODE - 4) << 2)	| pinConfig->Output_Speed) & 0x0f);
 80007e6:	683b      	ldr	r3, [r7, #0]
 80007e8:	789b      	ldrb	r3, [r3, #2]
 80007ea:	3b04      	subs	r3, #4
 80007ec:	009b      	lsls	r3, r3, #2
 80007ee:	b25a      	sxtb	r2, r3
 80007f0:	683b      	ldr	r3, [r7, #0]
 80007f2:	78db      	ldrb	r3, [r3, #3]
 80007f4:	b25b      	sxtb	r3, r3
 80007f6:	4313      	orrs	r3, r2
 80007f8:	b25b      	sxtb	r3, r3
 80007fa:	b2db      	uxtb	r3, r3
 80007fc:	f003 030f 	and.w	r3, r3, #15
 8000800:	75fb      	strb	r3, [r7, #23]
 8000802:	e02c      	b.n	800085e <GPIO_init+0xde>

	}
	else
	{
		if ((pinConfig->MODE == MODE_INPUT_FLO) || (pinConfig->MODE == MODE_Analog))
 8000804:	683b      	ldr	r3, [r7, #0]
 8000806:	789b      	ldrb	r3, [r3, #2]
 8000808:	2b01      	cmp	r3, #1
 800080a:	d003      	beq.n	8000814 <GPIO_init+0x94>
 800080c:	683b      	ldr	r3, [r7, #0]
 800080e:	789b      	ldrb	r3, [r3, #2]
 8000810:	2b00      	cmp	r3, #0
 8000812:	d107      	bne.n	8000824 <GPIO_init+0xa4>
		{
			register_bits = (((pinConfig->MODE << 2) | 0x00) & 0x0f);
 8000814:	683b      	ldr	r3, [r7, #0]
 8000816:	789b      	ldrb	r3, [r3, #2]
 8000818:	009b      	lsls	r3, r3, #2
 800081a:	b2db      	uxtb	r3, r3
 800081c:	f003 030f 	and.w	r3, r3, #15
 8000820:	75fb      	strb	r3, [r7, #23]
 8000822:	e01c      	b.n	800085e <GPIO_init+0xde>
		}
		else if (pinConfig->MODE == MODE_INPUT_AF)
 8000824:	683b      	ldr	r3, [r7, #0]
 8000826:	789b      	ldrb	r3, [r3, #2]
 8000828:	2b10      	cmp	r3, #16
 800082a:	d102      	bne.n	8000832 <GPIO_init+0xb2>
		{
			// consider alternative input as input floating
			register_bits = (((MODE_INPUT_FLO << 2) | 0x00) & 0x0f);
 800082c:	2304      	movs	r3, #4
 800082e:	75fb      	strb	r3, [r7, #23]
 8000830:	e015      	b.n	800085e <GPIO_init+0xde>
		}
		else
		{
			register_bits = (((MODE_INPUT_PU << 2) | 0x00) & 0x0f);
 8000832:	2308      	movs	r3, #8
 8000834:	75fb      	strb	r3, [r7, #23]
			if (pinConfig->MODE == MODE_INPUT_PU)
 8000836:	683b      	ldr	r3, [r7, #0]
 8000838:	789b      	ldrb	r3, [r3, #2]
 800083a:	2b02      	cmp	r3, #2
 800083c:	d107      	bne.n	800084e <GPIO_init+0xce>
			{
				// set ODR register 1 for input pull up
				GPIOx->ODR |= pinConfig->Pin_Number;
 800083e:	687b      	ldr	r3, [r7, #4]
 8000840:	68db      	ldr	r3, [r3, #12]
 8000842:	683a      	ldr	r2, [r7, #0]
 8000844:	8812      	ldrh	r2, [r2, #0]
 8000846:	431a      	orrs	r2, r3
 8000848:	687b      	ldr	r3, [r7, #4]
 800084a:	60da      	str	r2, [r3, #12]
 800084c:	e007      	b.n	800085e <GPIO_init+0xde>
			}
			else
			{
				// set ODR register 0 for input pull down
				GPIOx->ODR &= ~(pinConfig->Pin_Number);
 800084e:	687b      	ldr	r3, [r7, #4]
 8000850:	68db      	ldr	r3, [r3, #12]
 8000852:	683a      	ldr	r2, [r7, #0]
 8000854:	8812      	ldrh	r2, [r2, #0]
 8000856:	43d2      	mvns	r2, r2
 8000858:	401a      	ands	r2, r3
 800085a:	687b      	ldr	r3, [r7, #4]
 800085c:	60da      	str	r2, [r3, #12]
			}
		}

	}
	// write to CRL /CRH
	(*config_Register) |= (register_bits << shift_bit);
 800085e:	693b      	ldr	r3, [r7, #16]
 8000860:	681b      	ldr	r3, [r3, #0]
 8000862:	7df9      	ldrb	r1, [r7, #23]
 8000864:	7bfa      	ldrb	r2, [r7, #15]
 8000866:	fa01 f202 	lsl.w	r2, r1, r2
 800086a:	431a      	orrs	r2, r3
 800086c:	693b      	ldr	r3, [r7, #16]
 800086e:	601a      	str	r2, [r3, #0]
}
 8000870:	bf00      	nop
 8000872:	3718      	adds	r7, #24
 8000874:	46bd      	mov	sp, r7
 8000876:	bd80      	pop	{r7, pc}

08000878 <GPIO_WritePin>:
 * @param [in]	    - GPIOx : Select the port where the x can be (A..E depending on device used)
 * @param [in]	    - pinNumber : Must be a value from @ref GPIO_PINS_define
 * @param [in]	    - value : either HIGH or LOW from @ref GPIO_PIN_VALUE
 * @retval 			- none
 */
void GPIO_WritePin(GPIO_Registers_t *GPIOx, uint16 pinNumber, uint8 value) {
 8000878:	b480      	push	{r7}
 800087a:	b083      	sub	sp, #12
 800087c:	af00      	add	r7, sp, #0
 800087e:	6078      	str	r0, [r7, #4]
 8000880:	460b      	mov	r3, r1
 8000882:	807b      	strh	r3, [r7, #2]
 8000884:	4613      	mov	r3, r2
 8000886:	707b      	strb	r3, [r7, #1]
	if (value != PIN_LOW) {
 8000888:	787b      	ldrb	r3, [r7, #1]
 800088a:	2b00      	cmp	r3, #0
 800088c:	d006      	beq.n	800089c <GPIO_WritePin+0x24>
		GPIOx->ODR |= (uint32)(pinNumber);
 800088e:	687b      	ldr	r3, [r7, #4]
 8000890:	68da      	ldr	r2, [r3, #12]
 8000892:	887b      	ldrh	r3, [r7, #2]
 8000894:	431a      	orrs	r2, r3
 8000896:	687b      	ldr	r3, [r7, #4]
 8000898:	60da      	str	r2, [r3, #12]
	} else {
		GPIOx->ODR &= ~((uint32)(pinNumber));
	}
}
 800089a:	e006      	b.n	80008aa <GPIO_WritePin+0x32>
		GPIOx->ODR &= ~((uint32)(pinNumber));
 800089c:	687b      	ldr	r3, [r7, #4]
 800089e:	68da      	ldr	r2, [r3, #12]
 80008a0:	887b      	ldrh	r3, [r7, #2]
 80008a2:	43db      	mvns	r3, r3
 80008a4:	401a      	ands	r2, r3
 80008a6:	687b      	ldr	r3, [r7, #4]
 80008a8:	60da      	str	r2, [r3, #12]
}
 80008aa:	bf00      	nop
 80008ac:	370c      	adds	r7, #12
 80008ae:	46bd      	mov	sp, r7
 80008b0:	bc80      	pop	{r7}
 80008b2:	4770      	bx	lr

080008b4 <I2C1_EV_IRQHandler>:
}
uint8 I2C_Slave_RX(I2C_Registers_t *I2Cx){
	return (uint8)I2Cx->DR;
}

void I2C1_EV_IRQHandler(void){
 80008b4:	b580      	push	{r7, lr}
 80008b6:	b086      	sub	sp, #24
 80008b8:	af00      	add	r7, sp, #0
	volatile uint32 dummy_read = 0 ;
 80008ba:	2300      	movs	r3, #0
 80008bc:	607b      	str	r3, [r7, #4]
	I2C_Registers_t* I2Cx = I2C1 ;
 80008be:	4b37      	ldr	r3, [pc, #220]	; (800099c <I2C1_EV_IRQHandler+0xe8>)
 80008c0:	617b      	str	r3, [r7, #20]
		//Interrupt handling for both master and slave mode of a device
		uint32 temp1, temp2, temp3;

		temp1   = I2Cx->CR2 & (  1<<9) ;
 80008c2:	697b      	ldr	r3, [r7, #20]
 80008c4:	685b      	ldr	r3, [r3, #4]
 80008c6:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80008ca:	613b      	str	r3, [r7, #16]
		temp2   = I2Cx->CR2 & ( 1<<10) ;
 80008cc:	697b      	ldr	r3, [r7, #20]
 80008ce:	685b      	ldr	r3, [r3, #4]
 80008d0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80008d4:	60fb      	str	r3, [r7, #12]
		temp3  = I2Cx->SR1 & ( 1<<8);
 80008d6:	697b      	ldr	r3, [r7, #20]
 80008d8:	695b      	ldr	r3, [r3, #20]
 80008da:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80008de:	60bb      	str	r3, [r7, #8]


		// Handle For interrupt generated by STOPF event
			// Note : Stop detection flag is applicable only slave mode
			if(temp1 && temp3)
 80008e0:	693b      	ldr	r3, [r7, #16]
 80008e2:	2b00      	cmp	r3, #0
 80008e4:	d00a      	beq.n	80008fc <I2C1_EV_IRQHandler+0x48>
 80008e6:	68bb      	ldr	r3, [r7, #8]
 80008e8:	2b00      	cmp	r3, #0
 80008ea:	d007      	beq.n	80008fc <I2C1_EV_IRQHandler+0x48>
			{
				//STOF flag is set
				//Clear the STOPF ( i.e 1) read SR1 2) Write to CR1 )
				I2Cx->CR1 |= 0x0000;
 80008ec:	697b      	ldr	r3, [r7, #20]
 80008ee:	681a      	ldr	r2, [r3, #0]
 80008f0:	697b      	ldr	r3, [r7, #20]
 80008f2:	601a      	str	r2, [r3, #0]
				Slave_States(I2Cx,EV_STOP);
 80008f4:	2100      	movs	r1, #0
 80008f6:	6978      	ldr	r0, [r7, #20]
 80008f8:	f000 f852 	bl	80009a0 <Slave_States>


			}
			//----------------------------------------------------------
			temp3  = I2Cx->SR1 & (1<<1);
 80008fc:	697b      	ldr	r3, [r7, #20]
 80008fe:	695b      	ldr	r3, [r3, #20]
 8000900:	f003 0302 	and.w	r3, r3, #2
 8000904:	60bb      	str	r3, [r7, #8]
			// Handle For interrupt generated by ADDR event
			//Note : When master mode : Address is sent
			//		 When Slave mode   : Address matched with own address
			if(temp1 && temp3)
 8000906:	693b      	ldr	r3, [r7, #16]
 8000908:	2b00      	cmp	r3, #0
 800090a:	d012      	beq.n	8000932 <I2C1_EV_IRQHandler+0x7e>
 800090c:	68bb      	ldr	r3, [r7, #8]
 800090e:	2b00      	cmp	r3, #0
 8000910:	d00f      	beq.n	8000932 <I2C1_EV_IRQHandler+0x7e>
			{
				// interrupt is generated because of ADDR event
				//check for device mode
				if(I2Cx->SR2 & ( 1<<0))
 8000912:	697b      	ldr	r3, [r7, #20]
 8000914:	699b      	ldr	r3, [r3, #24]
 8000916:	f003 0301 	and.w	r3, r3, #1
 800091a:	2b00      	cmp	r3, #0
 800091c:	d109      	bne.n	8000932 <I2C1_EV_IRQHandler+0x7e>

				}else
				{
					//slave mode
					//clear the ADDR flag ( read SR1 , read SR2)
					dummy_read = I2Cx->SR1;
 800091e:	697b      	ldr	r3, [r7, #20]
 8000920:	695b      	ldr	r3, [r3, #20]
 8000922:	607b      	str	r3, [r7, #4]
					dummy_read = I2Cx->SR2;
 8000924:	697b      	ldr	r3, [r7, #20]
 8000926:	699b      	ldr	r3, [r3, #24]
 8000928:	607b      	str	r3, [r7, #4]
					Slave_States(I2Cx,EV_ADDR_Matched);
 800092a:	2102      	movs	r1, #2
 800092c:	6978      	ldr	r0, [r7, #20]
 800092e:	f000 f837 	bl	80009a0 <Slave_States>

				}
			}
			//----------------------------------------------------------

			temp3  = I2Cx->SR1 & ( 1<<7);
 8000932:	697b      	ldr	r3, [r7, #20]
 8000934:	695b      	ldr	r3, [r3, #20]
 8000936:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800093a:	60bb      	str	r3, [r7, #8]
			// Handle For interrupt generated by TXE event
			if(temp1 && temp2 && temp3)
 800093c:	693b      	ldr	r3, [r7, #16]
 800093e:	2b00      	cmp	r3, #0
 8000940:	d00f      	beq.n	8000962 <I2C1_EV_IRQHandler+0xae>
 8000942:	68fb      	ldr	r3, [r7, #12]
 8000944:	2b00      	cmp	r3, #0
 8000946:	d00c      	beq.n	8000962 <I2C1_EV_IRQHandler+0xae>
 8000948:	68bb      	ldr	r3, [r7, #8]
 800094a:	2b00      	cmp	r3, #0
 800094c:	d009      	beq.n	8000962 <I2C1_EV_IRQHandler+0xae>
			{
				//Check for device mode
				if(I2Cx->SR2 & (1<<0))
 800094e:	697b      	ldr	r3, [r7, #20]
 8000950:	699b      	ldr	r3, [r3, #24]
 8000952:	f003 0301 	and.w	r3, r3, #1
 8000956:	2b00      	cmp	r3, #0
 8000958:	d103      	bne.n	8000962 <I2C1_EV_IRQHandler+0xae>
				{

				}else
				{
					//slave
					Slave_States(I2Cx,EV_DATA_REQ);
 800095a:	2103      	movs	r1, #3
 800095c:	6978      	ldr	r0, [r7, #20]
 800095e:	f000 f81f 	bl	80009a0 <Slave_States>
				}
			}

			//----------------------------------------------------------

			temp3  = I2Cx->SR1 & ( 1<<6);
 8000962:	697b      	ldr	r3, [r7, #20]
 8000964:	695b      	ldr	r3, [r3, #20]
 8000966:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800096a:	60bb      	str	r3, [r7, #8]
			// Handle For interrupt generated by 	SB=1, cleared by reading SR1 register followed by writing DR register with Address.
			if(temp1 && temp2 && temp3)
 800096c:	693b      	ldr	r3, [r7, #16]
 800096e:	2b00      	cmp	r3, #0
 8000970:	d00f      	beq.n	8000992 <I2C1_EV_IRQHandler+0xde>
 8000972:	68fb      	ldr	r3, [r7, #12]
 8000974:	2b00      	cmp	r3, #0
 8000976:	d00c      	beq.n	8000992 <I2C1_EV_IRQHandler+0xde>
 8000978:	68bb      	ldr	r3, [r7, #8]
 800097a:	2b00      	cmp	r3, #0
 800097c:	d009      	beq.n	8000992 <I2C1_EV_IRQHandler+0xde>
			{
				//check device mode .
				if(I2Cx->SR2 & ( 1<<0))
 800097e:	697b      	ldr	r3, [r7, #20]
 8000980:	699b      	ldr	r3, [r3, #24]
 8000982:	f003 0301 	and.w	r3, r3, #1
 8000986:	2b00      	cmp	r3, #0
 8000988:	d103      	bne.n	8000992 <I2C1_EV_IRQHandler+0xde>
					//The device is master

				}else
				{
					//slave
					Slave_States(I2Cx,EV_DATA_REC);
 800098a:	2104      	movs	r1, #4
 800098c:	6978      	ldr	r0, [r7, #20]
 800098e:	f000 f807 	bl	80009a0 <Slave_States>

				}
			}
}
 8000992:	bf00      	nop
 8000994:	3718      	adds	r7, #24
 8000996:	46bd      	mov	sp, r7
 8000998:	bd80      	pop	{r7, pc}
 800099a:	bf00      	nop
 800099c:	40005400 	.word	0x40005400

080009a0 <Slave_States>:


void Slave_States (I2C_Registers_t* I2Cx  ,Slave_state state)
{
 80009a0:	b580      	push	{r7, lr}
 80009a2:	b084      	sub	sp, #16
 80009a4:	af00      	add	r7, sp, #0
 80009a6:	6078      	str	r0, [r7, #4]
 80009a8:	460b      	mov	r3, r1
 80009aa:	70fb      	strb	r3, [r7, #3]
	uint8 index =    I2Cx == I2C1 ? I2C1_Index: I2C2_Index ;
 80009ac:	687b      	ldr	r3, [r7, #4]
 80009ae:	4a2c      	ldr	r2, [pc, #176]	; (8000a60 <Slave_States+0xc0>)
 80009b0:	4293      	cmp	r3, r2
 80009b2:	bf14      	ite	ne
 80009b4:	2301      	movne	r3, #1
 80009b6:	2300      	moveq	r3, #0
 80009b8:	b2db      	uxtb	r3, r3
 80009ba:	73fb      	strb	r3, [r7, #15]

	switch (state)
 80009bc:	78fb      	ldrb	r3, [r7, #3]
 80009be:	2b04      	cmp	r3, #4
 80009c0:	d84a      	bhi.n	8000a58 <Slave_States+0xb8>
 80009c2:	a201      	add	r2, pc, #4	; (adr r2, 80009c8 <Slave_States+0x28>)
 80009c4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80009c8:	080009e3 	.word	0x080009e3
 80009cc:	080009dd 	.word	0x080009dd
 80009d0:	08000a01 	.word	0x08000a01
 80009d4:	08000a13 	.word	0x08000a13
 80009d8:	08000a31 	.word	0x08000a31
	{

	case ERR_AF:
	{
		//make sure that the slave is really in transmitter mode
		if(I2Cx->SR2 & ( 1<<2))
 80009dc:	687b      	ldr	r3, [r7, #4]
 80009de:	699b      	ldr	r3, [r3, #24]
		{
			//Slave Shouldn't Send anything else

		}

		break ;
 80009e0:	e03a      	b.n	8000a58 <Slave_States+0xb8>
	}

	case EV_STOP:
	{
		//make sure that the slave is really in transmitter mode
		if(I2Cx->SR2 & ( 1<<2))
 80009e2:	687b      	ldr	r3, [r7, #4]
 80009e4:	699b      	ldr	r3, [r3, #24]
 80009e6:	f003 0304 	and.w	r3, r3, #4
 80009ea:	2b00      	cmp	r3, #0
 80009ec:	d02f      	beq.n	8000a4e <Slave_States+0xae>
		{
			//Notify APP that the Stop Condition is sent by the master
			Global_I2C_pinConfig[index].P_Slave_CallBack_Fun (EV_STOP) ;
 80009ee:	7bfb      	ldrb	r3, [r7, #15]
 80009f0:	4a1c      	ldr	r2, [pc, #112]	; (8000a64 <Slave_States+0xc4>)
 80009f2:	015b      	lsls	r3, r3, #5
 80009f4:	4413      	add	r3, r2
 80009f6:	331c      	adds	r3, #28
 80009f8:	681b      	ldr	r3, [r3, #0]
 80009fa:	2000      	movs	r0, #0
 80009fc:	4798      	blx	r3
		}

		break ;
 80009fe:	e026      	b.n	8000a4e <Slave_States+0xae>
	}

	case EV_ADDR_Matched:
	{
		//Notify APP that the Stop Condition is sent by the master
		Global_I2C_pinConfig[index].P_Slave_CallBack_Fun (EV_ADDR_Matched) ;
 8000a00:	7bfb      	ldrb	r3, [r7, #15]
 8000a02:	4a18      	ldr	r2, [pc, #96]	; (8000a64 <Slave_States+0xc4>)
 8000a04:	015b      	lsls	r3, r3, #5
 8000a06:	4413      	add	r3, r2
 8000a08:	331c      	adds	r3, #28
 8000a0a:	681b      	ldr	r3, [r3, #0]
 8000a0c:	2002      	movs	r0, #2
 8000a0e:	4798      	blx	r3


		break ;
 8000a10:	e022      	b.n	8000a58 <Slave_States+0xb8>
	}

	case EV_DATA_REQ:
	{
		//make sure that the slave is really in transmitter mode
		if(I2Cx->SR2 & ( 1<<2))
 8000a12:	687b      	ldr	r3, [r7, #4]
 8000a14:	699b      	ldr	r3, [r3, #24]
 8000a16:	f003 0304 	and.w	r3, r3, #4
 8000a1a:	2b00      	cmp	r3, #0
 8000a1c:	d019      	beq.n	8000a52 <Slave_States+0xb2>
		{
			//the APP layer should send the data (MCAL_I2C_SlaveSendData ) in this state
			Global_I2C_pinConfig[index].P_Slave_CallBack_Fun (EV_DATA_REQ) ;
 8000a1e:	7bfb      	ldrb	r3, [r7, #15]
 8000a20:	4a10      	ldr	r2, [pc, #64]	; (8000a64 <Slave_States+0xc4>)
 8000a22:	015b      	lsls	r3, r3, #5
 8000a24:	4413      	add	r3, r2
 8000a26:	331c      	adds	r3, #28
 8000a28:	681b      	ldr	r3, [r3, #0]
 8000a2a:	2003      	movs	r0, #3
 8000a2c:	4798      	blx	r3

		}

		break ;
 8000a2e:	e010      	b.n	8000a52 <Slave_States+0xb2>
	}
	case EV_DATA_REC:
	{
		//make sure that the slave is really in receiver mode
		if(!(I2Cx->SR2 & ( 1<<2)))
 8000a30:	687b      	ldr	r3, [r7, #4]
 8000a32:	699b      	ldr	r3, [r3, #24]
 8000a34:	f003 0304 	and.w	r3, r3, #4
 8000a38:	2b00      	cmp	r3, #0
 8000a3a:	d10c      	bne.n	8000a56 <Slave_States+0xb6>
		{
			//the APP layer should read the data (MCAL_I2C_SlaveReceiveData ) in this state
			Global_I2C_pinConfig[index].P_Slave_CallBack_Fun (EV_DATA_REC) ;
 8000a3c:	7bfb      	ldrb	r3, [r7, #15]
 8000a3e:	4a09      	ldr	r2, [pc, #36]	; (8000a64 <Slave_States+0xc4>)
 8000a40:	015b      	lsls	r3, r3, #5
 8000a42:	4413      	add	r3, r2
 8000a44:	331c      	adds	r3, #28
 8000a46:	681b      	ldr	r3, [r3, #0]
 8000a48:	2004      	movs	r0, #4
 8000a4a:	4798      	blx	r3

		}

		break ;
 8000a4c:	e003      	b.n	8000a56 <Slave_States+0xb6>
		break ;
 8000a4e:	bf00      	nop
 8000a50:	e002      	b.n	8000a58 <Slave_States+0xb8>
		break ;
 8000a52:	bf00      	nop
 8000a54:	e000      	b.n	8000a58 <Slave_States+0xb8>
		break ;
 8000a56:	bf00      	nop
	}
	}

}
 8000a58:	bf00      	nop
 8000a5a:	3710      	adds	r7, #16
 8000a5c:	46bd      	mov	sp, r7
 8000a5e:	bd80      	pop	{r7, pc}
 8000a60:	40005400 	.word	0x40005400
 8000a64:	2000006c 	.word	0x2000006c

08000a68 <NVIC_Enable>:
 * @brief          - Enables the NVIC interrupt pin
 * @param [in]     - IRQ_Number :  The specified Interrupt Number to be enabled
 * @retval         - none
 */

void NVIC_Enable(uint8 IRQ_Number) {
 8000a68:	b480      	push	{r7}
 8000a6a:	b083      	sub	sp, #12
 8000a6c:	af00      	add	r7, sp, #0
 8000a6e:	4603      	mov	r3, r0
 8000a70:	71fb      	strb	r3, [r7, #7]
	if ((IRQ_Number >= 0) && (IRQ_Number <= 31)) {
 8000a72:	79fb      	ldrb	r3, [r7, #7]
 8000a74:	2b1f      	cmp	r3, #31
 8000a76:	d809      	bhi.n	8000a8c <NVIC_Enable+0x24>
		ISER0 |= (1U << IRQ_Number);
 8000a78:	4b0f      	ldr	r3, [pc, #60]	; (8000ab8 <NVIC_Enable+0x50>)
 8000a7a:	681a      	ldr	r2, [r3, #0]
 8000a7c:	79fb      	ldrb	r3, [r7, #7]
 8000a7e:	2101      	movs	r1, #1
 8000a80:	fa01 f303 	lsl.w	r3, r1, r3
 8000a84:	490c      	ldr	r1, [pc, #48]	; (8000ab8 <NVIC_Enable+0x50>)
 8000a86:	4313      	orrs	r3, r2
 8000a88:	600b      	str	r3, [r1, #0]
	} else if ((IRQ_Number >= 32) && (IRQ_Number <= 59)) {
		ISER1 |= (1U << (IRQ_Number - 32));
	}
}
 8000a8a:	e00f      	b.n	8000aac <NVIC_Enable+0x44>
	} else if ((IRQ_Number >= 32) && (IRQ_Number <= 59)) {
 8000a8c:	79fb      	ldrb	r3, [r7, #7]
 8000a8e:	2b1f      	cmp	r3, #31
 8000a90:	d90c      	bls.n	8000aac <NVIC_Enable+0x44>
 8000a92:	79fb      	ldrb	r3, [r7, #7]
 8000a94:	2b3b      	cmp	r3, #59	; 0x3b
 8000a96:	d809      	bhi.n	8000aac <NVIC_Enable+0x44>
		ISER1 |= (1U << (IRQ_Number - 32));
 8000a98:	4b08      	ldr	r3, [pc, #32]	; (8000abc <NVIC_Enable+0x54>)
 8000a9a:	681a      	ldr	r2, [r3, #0]
 8000a9c:	79fb      	ldrb	r3, [r7, #7]
 8000a9e:	3b20      	subs	r3, #32
 8000aa0:	2101      	movs	r1, #1
 8000aa2:	fa01 f303 	lsl.w	r3, r1, r3
 8000aa6:	4905      	ldr	r1, [pc, #20]	; (8000abc <NVIC_Enable+0x54>)
 8000aa8:	4313      	orrs	r3, r2
 8000aaa:	600b      	str	r3, [r1, #0]
}
 8000aac:	bf00      	nop
 8000aae:	370c      	adds	r7, #12
 8000ab0:	46bd      	mov	sp, r7
 8000ab2:	bc80      	pop	{r7}
 8000ab4:	4770      	bx	lr
 8000ab6:	bf00      	nop
 8000ab8:	e000e100 	.word	0xe000e100
 8000abc:	e000e104 	.word	0xe000e104

08000ac0 <NVIC_Disable>:
 * @brief          - Disables the NVIC interrupt pin
 * @param [in]     - IRQ_Number :  The specified Interrupt Number to be disabled
 * @retval         - none
 */

void NVIC_Disable(uint8 IRQ_Number) {
 8000ac0:	b480      	push	{r7}
 8000ac2:	b083      	sub	sp, #12
 8000ac4:	af00      	add	r7, sp, #0
 8000ac6:	4603      	mov	r3, r0
 8000ac8:	71fb      	strb	r3, [r7, #7]
	if ((IRQ_Number >= 0) && (IRQ_Number <= 31)) {
 8000aca:	79fb      	ldrb	r3, [r7, #7]
 8000acc:	2b1f      	cmp	r3, #31
 8000ace:	d809      	bhi.n	8000ae4 <NVIC_Disable+0x24>
		ICER0 |= (1U << IRQ_Number);
 8000ad0:	4b0f      	ldr	r3, [pc, #60]	; (8000b10 <NVIC_Disable+0x50>)
 8000ad2:	681a      	ldr	r2, [r3, #0]
 8000ad4:	79fb      	ldrb	r3, [r7, #7]
 8000ad6:	2101      	movs	r1, #1
 8000ad8:	fa01 f303 	lsl.w	r3, r1, r3
 8000adc:	490c      	ldr	r1, [pc, #48]	; (8000b10 <NVIC_Disable+0x50>)
 8000ade:	4313      	orrs	r3, r2
 8000ae0:	600b      	str	r3, [r1, #0]
	} else if ((IRQ_Number >= 32) && (IRQ_Number <= 59)) {
		ICER1 |= (1U << (IRQ_Number - 32));
	}
}
 8000ae2:	e00f      	b.n	8000b04 <NVIC_Disable+0x44>
	} else if ((IRQ_Number >= 32) && (IRQ_Number <= 59)) {
 8000ae4:	79fb      	ldrb	r3, [r7, #7]
 8000ae6:	2b1f      	cmp	r3, #31
 8000ae8:	d90c      	bls.n	8000b04 <NVIC_Disable+0x44>
 8000aea:	79fb      	ldrb	r3, [r7, #7]
 8000aec:	2b3b      	cmp	r3, #59	; 0x3b
 8000aee:	d809      	bhi.n	8000b04 <NVIC_Disable+0x44>
		ICER1 |= (1U << (IRQ_Number - 32));
 8000af0:	4b08      	ldr	r3, [pc, #32]	; (8000b14 <NVIC_Disable+0x54>)
 8000af2:	681a      	ldr	r2, [r3, #0]
 8000af4:	79fb      	ldrb	r3, [r7, #7]
 8000af6:	3b20      	subs	r3, #32
 8000af8:	2101      	movs	r1, #1
 8000afa:	fa01 f303 	lsl.w	r3, r1, r3
 8000afe:	4905      	ldr	r1, [pc, #20]	; (8000b14 <NVIC_Disable+0x54>)
 8000b00:	4313      	orrs	r3, r2
 8000b02:	600b      	str	r3, [r1, #0]
}
 8000b04:	bf00      	nop
 8000b06:	370c      	adds	r7, #12
 8000b08:	46bd      	mov	sp, r7
 8000b0a:	bc80      	pop	{r7}
 8000b0c:	4770      	bx	lr
 8000b0e:	bf00      	nop
 8000b10:	e000e180 	.word	0xe000e180
 8000b14:	e000e184 	.word	0xe000e184

08000b18 <RCC_CLK_EN>:
		break;

	}
}

void RCC_CLK_EN(uint8 busID, uint8 periphralID) {
 8000b18:	b480      	push	{r7}
 8000b1a:	b083      	sub	sp, #12
 8000b1c:	af00      	add	r7, sp, #0
 8000b1e:	4603      	mov	r3, r0
 8000b20:	460a      	mov	r2, r1
 8000b22:	71fb      	strb	r3, [r7, #7]
 8000b24:	4613      	mov	r3, r2
 8000b26:	71bb      	strb	r3, [r7, #6]
	switch (busID) {
 8000b28:	79fb      	ldrb	r3, [r7, #7]
 8000b2a:	2b02      	cmp	r3, #2
 8000b2c:	d01c      	beq.n	8000b68 <RCC_CLK_EN+0x50>
 8000b2e:	2b02      	cmp	r3, #2
 8000b30:	dc25      	bgt.n	8000b7e <RCC_CLK_EN+0x66>
 8000b32:	2b00      	cmp	r3, #0
 8000b34:	d002      	beq.n	8000b3c <RCC_CLK_EN+0x24>
 8000b36:	2b01      	cmp	r3, #1
 8000b38:	d00b      	beq.n	8000b52 <RCC_CLK_EN+0x3a>
		break;
	case AHB_ID:
		RCC->AHBENR |= (1 << periphralID);
		break;
	}
}
 8000b3a:	e020      	b.n	8000b7e <RCC_CLK_EN+0x66>
		RCC->ABP1ENR |= (1 << periphralID);
 8000b3c:	4b12      	ldr	r3, [pc, #72]	; (8000b88 <RCC_CLK_EN+0x70>)
 8000b3e:	69db      	ldr	r3, [r3, #28]
 8000b40:	79ba      	ldrb	r2, [r7, #6]
 8000b42:	2101      	movs	r1, #1
 8000b44:	fa01 f202 	lsl.w	r2, r1, r2
 8000b48:	4611      	mov	r1, r2
 8000b4a:	4a0f      	ldr	r2, [pc, #60]	; (8000b88 <RCC_CLK_EN+0x70>)
 8000b4c:	430b      	orrs	r3, r1
 8000b4e:	61d3      	str	r3, [r2, #28]
		break;
 8000b50:	e015      	b.n	8000b7e <RCC_CLK_EN+0x66>
		RCC->ABP2ENR |= (1 << periphralID);
 8000b52:	4b0d      	ldr	r3, [pc, #52]	; (8000b88 <RCC_CLK_EN+0x70>)
 8000b54:	699b      	ldr	r3, [r3, #24]
 8000b56:	79ba      	ldrb	r2, [r7, #6]
 8000b58:	2101      	movs	r1, #1
 8000b5a:	fa01 f202 	lsl.w	r2, r1, r2
 8000b5e:	4611      	mov	r1, r2
 8000b60:	4a09      	ldr	r2, [pc, #36]	; (8000b88 <RCC_CLK_EN+0x70>)
 8000b62:	430b      	orrs	r3, r1
 8000b64:	6193      	str	r3, [r2, #24]
		break;
 8000b66:	e00a      	b.n	8000b7e <RCC_CLK_EN+0x66>
		RCC->AHBENR |= (1 << periphralID);
 8000b68:	4b07      	ldr	r3, [pc, #28]	; (8000b88 <RCC_CLK_EN+0x70>)
 8000b6a:	695b      	ldr	r3, [r3, #20]
 8000b6c:	79ba      	ldrb	r2, [r7, #6]
 8000b6e:	2101      	movs	r1, #1
 8000b70:	fa01 f202 	lsl.w	r2, r1, r2
 8000b74:	4611      	mov	r1, r2
 8000b76:	4a04      	ldr	r2, [pc, #16]	; (8000b88 <RCC_CLK_EN+0x70>)
 8000b78:	430b      	orrs	r3, r1
 8000b7a:	6153      	str	r3, [r2, #20]
		break;
 8000b7c:	bf00      	nop
}
 8000b7e:	bf00      	nop
 8000b80:	370c      	adds	r7, #12
 8000b82:	46bd      	mov	sp, r7
 8000b84:	bc80      	pop	{r7}
 8000b86:	4770      	bx	lr
 8000b88:	40021000 	.word	0x40021000

08000b8c <SPI_init>:
 * @Fn				- SPI_init
 * @brief 			- Initializes SPI
 * @param [in]	    - SPI_pinConfig :  pointer to a structure that contains the pin configuration information
 * @param [in]	    - SPIx : Pointer to the SPI number where x could be 1 or 2 depending on the device
 */
void SPI_init(SPI_PinConfig_t *SPI_pinConfig, SPI_Registers_t *SPIx) {
 8000b8c:	b5b0      	push	{r4, r5, r7, lr}
 8000b8e:	b084      	sub	sp, #16
 8000b90:	af00      	add	r7, sp, #0
 8000b92:	6078      	str	r0, [r7, #4]
 8000b94:	6039      	str	r1, [r7, #0]
	// for Safety of registers
	uint16 tmpreg_CR1 = 0;
 8000b96:	2300      	movs	r3, #0
 8000b98:	81fb      	strh	r3, [r7, #14]
	uint16 tmpreg_CR2 = 0;
 8000b9a:	2300      	movs	r3, #0
 8000b9c:	81bb      	strh	r3, [r7, #12]

	/*            		Enable SPI clocks  					    */
	if (SPIx == SPI1) {
 8000b9e:	683b      	ldr	r3, [r7, #0]
 8000ba0:	4a4b      	ldr	r2, [pc, #300]	; (8000cd0 <SPI_init+0x144>)
 8000ba2:	4293      	cmp	r3, r2
 8000ba4:	d10e      	bne.n	8000bc4 <SPI_init+0x38>
		Global_SPI_pinConfig[SPI1_Index] = *SPI_pinConfig;
 8000ba6:	4a4b      	ldr	r2, [pc, #300]	; (8000cd4 <SPI_init+0x148>)
 8000ba8:	687b      	ldr	r3, [r7, #4]
 8000baa:	4614      	mov	r4, r2
 8000bac:	461d      	mov	r5, r3
 8000bae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000bb0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000bb2:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000bb6:	e884 0003 	stmia.w	r4, {r0, r1}
		RCC_CLK_EN(APB2_ID,SPI1_ID);
 8000bba:	210c      	movs	r1, #12
 8000bbc:	2001      	movs	r0, #1
 8000bbe:	f7ff ffab 	bl	8000b18 <RCC_CLK_EN>
 8000bc2:	e012      	b.n	8000bea <SPI_init+0x5e>
	} else if (SPIx == SPI2) {
 8000bc4:	683b      	ldr	r3, [r7, #0]
 8000bc6:	4a44      	ldr	r2, [pc, #272]	; (8000cd8 <SPI_init+0x14c>)
 8000bc8:	4293      	cmp	r3, r2
 8000bca:	d10e      	bne.n	8000bea <SPI_init+0x5e>
		Global_SPI_pinConfig[SPI2_Index] = *SPI_pinConfig;
 8000bcc:	4b41      	ldr	r3, [pc, #260]	; (8000cd4 <SPI_init+0x148>)
 8000bce:	687a      	ldr	r2, [r7, #4]
 8000bd0:	f103 0418 	add.w	r4, r3, #24
 8000bd4:	4615      	mov	r5, r2
 8000bd6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000bd8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000bda:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000bde:	e884 0003 	stmia.w	r4, {r0, r1}
		RCC_CLK_EN(APB1_ID,SPI2_ID);
 8000be2:	210e      	movs	r1, #14
 8000be4:	2000      	movs	r0, #0
 8000be6:	f7ff ff97 	bl	8000b18 <RCC_CLK_EN>
	}

	/*			Enable SPI Module       */
	tmpreg_CR1  |= (1 << 6);		 //SPE: SPI enable
 8000bea:	89fb      	ldrh	r3, [r7, #14]
 8000bec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000bf0:	81fb      	strh	r3, [r7, #14]
	/*			Configure SPI Mode	  						*/
	tmpreg_CR1 |= SPI_pinConfig->SPI_Mode;
 8000bf2:	687b      	ldr	r3, [r7, #4]
 8000bf4:	881a      	ldrh	r2, [r3, #0]
 8000bf6:	89fb      	ldrh	r3, [r7, #14]
 8000bf8:	4313      	orrs	r3, r2
 8000bfa:	81fb      	strh	r3, [r7, #14]
	/*			Configure SPI Commuincation Mode		*/
	tmpreg_CR1 |= SPI_pinConfig->Commuincation_Mode;
 8000bfc:	687b      	ldr	r3, [r7, #4]
 8000bfe:	885a      	ldrh	r2, [r3, #2]
 8000c00:	89fb      	ldrh	r3, [r7, #14]
 8000c02:	4313      	orrs	r3, r2
 8000c04:	81fb      	strh	r3, [r7, #14]
	/*			Configure Data Size 		*/
	tmpreg_CR1 |= SPI_pinConfig->Data_Size;
 8000c06:	687b      	ldr	r3, [r7, #4]
 8000c08:	889a      	ldrh	r2, [r3, #4]
 8000c0a:	89fb      	ldrh	r3, [r7, #14]
 8000c0c:	4313      	orrs	r3, r2
 8000c0e:	81fb      	strh	r3, [r7, #14]
	/*			Configure Frame Format		*/
	tmpreg_CR1 |= SPI_pinConfig->Frame_Format;
 8000c10:	687b      	ldr	r3, [r7, #4]
 8000c12:	88da      	ldrh	r2, [r3, #6]
 8000c14:	89fb      	ldrh	r3, [r7, #14]
 8000c16:	4313      	orrs	r3, r2
 8000c18:	81fb      	strh	r3, [r7, #14]
	/*			Configure BaudRate		*/
	tmpreg_CR1 |= SPI_pinConfig->BaudRate;
 8000c1a:	687b      	ldr	r3, [r7, #4]
 8000c1c:	891a      	ldrh	r2, [r3, #8]
 8000c1e:	89fb      	ldrh	r3, [r7, #14]
 8000c20:	4313      	orrs	r3, r2
 8000c22:	81fb      	strh	r3, [r7, #14]

	/*			Configure NSS		*/
	if (SPI_pinConfig->NSS == SPI_NSS_Hard_Master_output_enable)
 8000c24:	687b      	ldr	r3, [r7, #4]
 8000c26:	895b      	ldrh	r3, [r3, #10]
 8000c28:	2b04      	cmp	r3, #4
 8000c2a:	d105      	bne.n	8000c38 <SPI_init+0xac>
		tmpreg_CR2 |= SPI_pinConfig->NSS;
 8000c2c:	687b      	ldr	r3, [r7, #4]
 8000c2e:	895a      	ldrh	r2, [r3, #10]
 8000c30:	89bb      	ldrh	r3, [r7, #12]
 8000c32:	4313      	orrs	r3, r2
 8000c34:	81bb      	strh	r3, [r7, #12]
 8000c36:	e00e      	b.n	8000c56 <SPI_init+0xca>
	else if (SPI_pinConfig->NSS == SPI_NSS_Hard_Master_output_disable || SPI_pinConfig->NSS == SPI_NSS_Hard_Slave)
 8000c38:	687b      	ldr	r3, [r7, #4]
 8000c3a:	895b      	ldrh	r3, [r3, #10]
 8000c3c:	2b00      	cmp	r3, #0
 8000c3e:	d105      	bne.n	8000c4c <SPI_init+0xc0>
		tmpreg_CR2 &= SPI_pinConfig->NSS;
 8000c40:	687b      	ldr	r3, [r7, #4]
 8000c42:	895a      	ldrh	r2, [r3, #10]
 8000c44:	89bb      	ldrh	r3, [r7, #12]
 8000c46:	4013      	ands	r3, r2
 8000c48:	81bb      	strh	r3, [r7, #12]
 8000c4a:	e004      	b.n	8000c56 <SPI_init+0xca>
	else
		tmpreg_CR1 |= SPI_pinConfig->NSS;
 8000c4c:	687b      	ldr	r3, [r7, #4]
 8000c4e:	895a      	ldrh	r2, [r3, #10]
 8000c50:	89fb      	ldrh	r3, [r7, #14]
 8000c52:	4313      	orrs	r3, r2
 8000c54:	81fb      	strh	r3, [r7, #14]

	/*			Configure Clock Polarity		*/
	tmpreg_CR1 |= SPI_pinConfig->CLK_Polarity;
 8000c56:	687b      	ldr	r3, [r7, #4]
 8000c58:	899a      	ldrh	r2, [r3, #12]
 8000c5a:	89fb      	ldrh	r3, [r7, #14]
 8000c5c:	4313      	orrs	r3, r2
 8000c5e:	81fb      	strh	r3, [r7, #14]
	/*			Configure Clock Phase		*/
	tmpreg_CR1 |= SPI_pinConfig->CLK_Phase;
 8000c60:	687b      	ldr	r3, [r7, #4]
 8000c62:	89da      	ldrh	r2, [r3, #14]
 8000c64:	89fb      	ldrh	r3, [r7, #14]
 8000c66:	4313      	orrs	r3, r2
 8000c68:	81fb      	strh	r3, [r7, #14]

	/*			Enable interrupts		*/
	if (SPI_pinConfig->IRQ_Enable != SPI_IRQ_EN_None) {
 8000c6a:	687b      	ldr	r3, [r7, #4]
 8000c6c:	8a1b      	ldrh	r3, [r3, #16]
 8000c6e:	2b00      	cmp	r3, #0
 8000c70:	d014      	beq.n	8000c9c <SPI_init+0x110>
		tmpreg_CR2 |= SPI_pinConfig->IRQ_Enable;
 8000c72:	687b      	ldr	r3, [r7, #4]
 8000c74:	8a1a      	ldrh	r2, [r3, #16]
 8000c76:	89bb      	ldrh	r3, [r7, #12]
 8000c78:	4313      	orrs	r3, r2
 8000c7a:	81bb      	strh	r3, [r7, #12]
		if (SPIx == SPI1)
 8000c7c:	683b      	ldr	r3, [r7, #0]
 8000c7e:	4a14      	ldr	r2, [pc, #80]	; (8000cd0 <SPI_init+0x144>)
 8000c80:	4293      	cmp	r3, r2
 8000c82:	d103      	bne.n	8000c8c <SPI_init+0x100>
			NVIC_Enable(NVIC_SPI1);
 8000c84:	2023      	movs	r0, #35	; 0x23
 8000c86:	f7ff feef 	bl	8000a68 <NVIC_Enable>
 8000c8a:	e016      	b.n	8000cba <SPI_init+0x12e>
		else if (SPIx == SPI2)
 8000c8c:	683b      	ldr	r3, [r7, #0]
 8000c8e:	4a12      	ldr	r2, [pc, #72]	; (8000cd8 <SPI_init+0x14c>)
 8000c90:	4293      	cmp	r3, r2
 8000c92:	d112      	bne.n	8000cba <SPI_init+0x12e>
			NVIC_Enable(NVIC_SPI2);
 8000c94:	2024      	movs	r0, #36	; 0x24
 8000c96:	f7ff fee7 	bl	8000a68 <NVIC_Enable>
 8000c9a:	e00e      	b.n	8000cba <SPI_init+0x12e>
	} else {
		if (SPIx == SPI1)
 8000c9c:	683b      	ldr	r3, [r7, #0]
 8000c9e:	4a0c      	ldr	r2, [pc, #48]	; (8000cd0 <SPI_init+0x144>)
 8000ca0:	4293      	cmp	r3, r2
 8000ca2:	d103      	bne.n	8000cac <SPI_init+0x120>
			NVIC_Disable(NVIC_SPI1);
 8000ca4:	2023      	movs	r0, #35	; 0x23
 8000ca6:	f7ff ff0b 	bl	8000ac0 <NVIC_Disable>
 8000caa:	e006      	b.n	8000cba <SPI_init+0x12e>
		else if (SPIx == SPI2)
 8000cac:	683b      	ldr	r3, [r7, #0]
 8000cae:	4a0a      	ldr	r2, [pc, #40]	; (8000cd8 <SPI_init+0x14c>)
 8000cb0:	4293      	cmp	r3, r2
 8000cb2:	d102      	bne.n	8000cba <SPI_init+0x12e>
			NVIC_Disable(NVIC_SPI2);
 8000cb4:	2024      	movs	r0, #36	; 0x24
 8000cb6:	f7ff ff03 	bl	8000ac0 <NVIC_Disable>
	}

	SPIx->CR1 = tmpreg_CR1;
 8000cba:	89fa      	ldrh	r2, [r7, #14]
 8000cbc:	683b      	ldr	r3, [r7, #0]
 8000cbe:	601a      	str	r2, [r3, #0]
	SPIx->CR2 = tmpreg_CR2;
 8000cc0:	89ba      	ldrh	r2, [r7, #12]
 8000cc2:	683b      	ldr	r3, [r7, #0]
 8000cc4:	605a      	str	r2, [r3, #4]

}
 8000cc6:	bf00      	nop
 8000cc8:	3710      	adds	r7, #16
 8000cca:	46bd      	mov	sp, r7
 8000ccc:	bdb0      	pop	{r4, r5, r7, pc}
 8000cce:	bf00      	nop
 8000cd0:	40013000 	.word	0x40013000
 8000cd4:	200000ac 	.word	0x200000ac
 8000cd8:	40003800 	.word	0x40003800

08000cdc <SPI_GPIO_SetPins>:
 * @brief 			-initialize GPIO Pins
 * @param [in] 		-SPIx: where x can be (1..2 depending on device used)
 * @retval 			-none
 * @Note			-Should enable the corresponding ALT  & GPIO  in RCC clock Also called after SPI_init()
 */
void SPI_GPIO_SetPins(SPI_Registers_t *SPIx) {
 8000cdc:	b580      	push	{r7, lr}
 8000cde:	b084      	sub	sp, #16
 8000ce0:	af00      	add	r7, sp, #0
 8000ce2:	6078      	str	r0, [r7, #4]
	GPIO_PinConfig_t GPIO_pinConfig;
	if (SPIx == SPI1) {
 8000ce4:	687b      	ldr	r3, [r7, #4]
 8000ce6:	4a70      	ldr	r2, [pc, #448]	; (8000ea8 <SPI_GPIO_SetPins+0x1cc>)
 8000ce8:	4293      	cmp	r3, r2
 8000cea:	d166      	bne.n	8000dba <SPI_GPIO_SetPins+0xde>
		// MASTER
		if (Global_SPI_pinConfig[SPI1_Index].SPI_Mode == SPI_Mode_Master) {
 8000cec:	4b6f      	ldr	r3, [pc, #444]	; (8000eac <SPI_GPIO_SetPins+0x1d0>)
 8000cee:	881b      	ldrh	r3, [r3, #0]
 8000cf0:	2b04      	cmp	r3, #4
 8000cf2:	d133      	bne.n	8000d5c <SPI_GPIO_SetPins+0x80>
			// NSS
			switch(Global_SPI_pinConfig[SPI1_Index].NSS)
 8000cf4:	4b6d      	ldr	r3, [pc, #436]	; (8000eac <SPI_GPIO_SetPins+0x1d0>)
 8000cf6:	895b      	ldrh	r3, [r3, #10]
 8000cf8:	2b04      	cmp	r3, #4
 8000cfa:	d10c      	bne.n	8000d16 <SPI_GPIO_SetPins+0x3a>
				GPIO_pinConfig.MODE = MODE_INPUT_FLO;
				GPIO_pinConfig.Pin_Number = PIN_4;
				GPIO_init(GPIOA, &GPIO_pinConfig);
				break;
				case SPI_NSS_Hard_Master_output_enable :
				GPIO_pinConfig.MODE = MODE_OUTPUT_AF_PP;
 8000cfc:	2306      	movs	r3, #6
 8000cfe:	73bb      	strb	r3, [r7, #14]
				GPIO_pinConfig.Output_Speed = SPEED_10M;
 8000d00:	2301      	movs	r3, #1
 8000d02:	73fb      	strb	r3, [r7, #15]
				GPIO_pinConfig.Pin_Number = PIN_4;
 8000d04:	2310      	movs	r3, #16
 8000d06:	81bb      	strh	r3, [r7, #12]
				GPIO_init(GPIOA, &GPIO_pinConfig);
 8000d08:	f107 030c 	add.w	r3, r7, #12
 8000d0c:	4619      	mov	r1, r3
 8000d0e:	4868      	ldr	r0, [pc, #416]	; (8000eb0 <SPI_GPIO_SetPins+0x1d4>)
 8000d10:	f7ff fd36 	bl	8000780 <GPIO_init>
				break;
 8000d14:	bf00      	nop
			}
			// SCLK
			GPIO_pinConfig.MODE = MODE_OUTPUT_PP;
 8000d16:	2304      	movs	r3, #4
 8000d18:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Output_Speed = SPEED_10M;
 8000d1a:	2301      	movs	r3, #1
 8000d1c:	73fb      	strb	r3, [r7, #15]
			GPIO_pinConfig.Pin_Number = PIN_5;
 8000d1e:	2320      	movs	r3, #32
 8000d20:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOA, &GPIO_pinConfig);
 8000d22:	f107 030c 	add.w	r3, r7, #12
 8000d26:	4619      	mov	r1, r3
 8000d28:	4861      	ldr	r0, [pc, #388]	; (8000eb0 <SPI_GPIO_SetPins+0x1d4>)
 8000d2a:	f7ff fd29 	bl	8000780 <GPIO_init>
			// MOSI
			GPIO_pinConfig.MODE = MODE_OUTPUT_PP;
 8000d2e:	2304      	movs	r3, #4
 8000d30:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Output_Speed = SPEED_10M;
 8000d32:	2301      	movs	r3, #1
 8000d34:	73fb      	strb	r3, [r7, #15]
			GPIO_pinConfig.Pin_Number = PIN_7;
 8000d36:	2380      	movs	r3, #128	; 0x80
 8000d38:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOA, &GPIO_pinConfig);
 8000d3a:	f107 030c 	add.w	r3, r7, #12
 8000d3e:	4619      	mov	r1, r3
 8000d40:	485b      	ldr	r0, [pc, #364]	; (8000eb0 <SPI_GPIO_SetPins+0x1d4>)
 8000d42:	f7ff fd1d 	bl	8000780 <GPIO_init>
			//MISO
			GPIO_pinConfig.MODE = MODE_INPUT_FLO;
 8000d46:	2301      	movs	r3, #1
 8000d48:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Pin_Number = PIN_6;
 8000d4a:	2340      	movs	r3, #64	; 0x40
 8000d4c:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOA, &GPIO_pinConfig);
 8000d4e:	f107 030c 	add.w	r3, r7, #12
 8000d52:	4619      	mov	r1, r3
 8000d54:	4856      	ldr	r0, [pc, #344]	; (8000eb0 <SPI_GPIO_SetPins+0x1d4>)
 8000d56:	f7ff fd13 	bl	8000780 <GPIO_init>
			GPIO_init(GPIOB, &GPIO_pinConfig);
		}

	}

}
 8000d5a:	e0a0      	b.n	8000e9e <SPI_GPIO_SetPins+0x1c2>
			if (Global_SPI_pinConfig[SPI1_Index].SPI_Mode == SPI_NSS_Hard_Slave) {
 8000d5c:	4b53      	ldr	r3, [pc, #332]	; (8000eac <SPI_GPIO_SetPins+0x1d0>)
 8000d5e:	881b      	ldrh	r3, [r3, #0]
 8000d60:	2b00      	cmp	r3, #0
 8000d62:	d109      	bne.n	8000d78 <SPI_GPIO_SetPins+0x9c>
				GPIO_pinConfig.MODE = MODE_INPUT_FLO;
 8000d64:	2301      	movs	r3, #1
 8000d66:	73bb      	strb	r3, [r7, #14]
				GPIO_pinConfig.Pin_Number = PIN_4;
 8000d68:	2310      	movs	r3, #16
 8000d6a:	81bb      	strh	r3, [r7, #12]
				GPIO_init(GPIOA, &GPIO_pinConfig);
 8000d6c:	f107 030c 	add.w	r3, r7, #12
 8000d70:	4619      	mov	r1, r3
 8000d72:	484f      	ldr	r0, [pc, #316]	; (8000eb0 <SPI_GPIO_SetPins+0x1d4>)
 8000d74:	f7ff fd04 	bl	8000780 <GPIO_init>
			GPIO_pinConfig.MODE = MODE_INPUT_FLO;
 8000d78:	2301      	movs	r3, #1
 8000d7a:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Pin_Number = PIN_5;
 8000d7c:	2320      	movs	r3, #32
 8000d7e:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOA, &GPIO_pinConfig);
 8000d80:	f107 030c 	add.w	r3, r7, #12
 8000d84:	4619      	mov	r1, r3
 8000d86:	484a      	ldr	r0, [pc, #296]	; (8000eb0 <SPI_GPIO_SetPins+0x1d4>)
 8000d88:	f7ff fcfa 	bl	8000780 <GPIO_init>
			GPIO_pinConfig.MODE = MODE_INPUT_FLO;
 8000d8c:	2301      	movs	r3, #1
 8000d8e:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Pin_Number = PIN_7;
 8000d90:	2380      	movs	r3, #128	; 0x80
 8000d92:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOA, &GPIO_pinConfig);
 8000d94:	f107 030c 	add.w	r3, r7, #12
 8000d98:	4619      	mov	r1, r3
 8000d9a:	4845      	ldr	r0, [pc, #276]	; (8000eb0 <SPI_GPIO_SetPins+0x1d4>)
 8000d9c:	f7ff fcf0 	bl	8000780 <GPIO_init>
			GPIO_pinConfig.MODE = MODE_OUTPUT_AF_PP;
 8000da0:	2306      	movs	r3, #6
 8000da2:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Output_Speed = SPEED_10M;
 8000da4:	2301      	movs	r3, #1
 8000da6:	73fb      	strb	r3, [r7, #15]
			GPIO_pinConfig.Pin_Number = PIN_6;
 8000da8:	2340      	movs	r3, #64	; 0x40
 8000daa:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOA, &GPIO_pinConfig);
 8000dac:	f107 030c 	add.w	r3, r7, #12
 8000db0:	4619      	mov	r1, r3
 8000db2:	483f      	ldr	r0, [pc, #252]	; (8000eb0 <SPI_GPIO_SetPins+0x1d4>)
 8000db4:	f7ff fce4 	bl	8000780 <GPIO_init>
}
 8000db8:	e071      	b.n	8000e9e <SPI_GPIO_SetPins+0x1c2>
	} else if (SPIx == SPI2) {
 8000dba:	687b      	ldr	r3, [r7, #4]
 8000dbc:	4a3d      	ldr	r2, [pc, #244]	; (8000eb4 <SPI_GPIO_SetPins+0x1d8>)
 8000dbe:	4293      	cmp	r3, r2
 8000dc0:	d16d      	bne.n	8000e9e <SPI_GPIO_SetPins+0x1c2>
		if (Global_SPI_pinConfig[SPI2_Index].SPI_Mode == SPI_Mode_Master) {
 8000dc2:	4b3a      	ldr	r3, [pc, #232]	; (8000eac <SPI_GPIO_SetPins+0x1d0>)
 8000dc4:	8b1b      	ldrh	r3, [r3, #24]
 8000dc6:	2b04      	cmp	r3, #4
 8000dc8:	d137      	bne.n	8000e3a <SPI_GPIO_SetPins+0x15e>
			switch(Global_SPI_pinConfig[SPI2_Index].NSS)
 8000dca:	4b38      	ldr	r3, [pc, #224]	; (8000eac <SPI_GPIO_SetPins+0x1d0>)
 8000dcc:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8000dce:	2b04      	cmp	r3, #4
 8000dd0:	d10d      	bne.n	8000dee <SPI_GPIO_SetPins+0x112>
				GPIO_pinConfig.MODE = MODE_OUTPUT_AF_PP;
 8000dd2:	2306      	movs	r3, #6
 8000dd4:	73bb      	strb	r3, [r7, #14]
				GPIO_pinConfig.Output_Speed = SPEED_10M;
 8000dd6:	2301      	movs	r3, #1
 8000dd8:	73fb      	strb	r3, [r7, #15]
				GPIO_pinConfig.Pin_Number = PIN_12;
 8000dda:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000dde:	81bb      	strh	r3, [r7, #12]
				GPIO_init(GPIOB, &GPIO_pinConfig);
 8000de0:	f107 030c 	add.w	r3, r7, #12
 8000de4:	4619      	mov	r1, r3
 8000de6:	4834      	ldr	r0, [pc, #208]	; (8000eb8 <SPI_GPIO_SetPins+0x1dc>)
 8000de8:	f7ff fcca 	bl	8000780 <GPIO_init>
				break;
 8000dec:	bf00      	nop
			GPIO_pinConfig.MODE = MODE_OUTPUT_AF_PP;
 8000dee:	2306      	movs	r3, #6
 8000df0:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Output_Speed = SPEED_10M;
 8000df2:	2301      	movs	r3, #1
 8000df4:	73fb      	strb	r3, [r7, #15]
			GPIO_pinConfig.Pin_Number = PIN_13;
 8000df6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000dfa:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOB, &GPIO_pinConfig);
 8000dfc:	f107 030c 	add.w	r3, r7, #12
 8000e00:	4619      	mov	r1, r3
 8000e02:	482d      	ldr	r0, [pc, #180]	; (8000eb8 <SPI_GPIO_SetPins+0x1dc>)
 8000e04:	f7ff fcbc 	bl	8000780 <GPIO_init>
			GPIO_pinConfig.MODE = MODE_OUTPUT_AF_PP;
 8000e08:	2306      	movs	r3, #6
 8000e0a:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Output_Speed = SPEED_10M;
 8000e0c:	2301      	movs	r3, #1
 8000e0e:	73fb      	strb	r3, [r7, #15]
			GPIO_pinConfig.Pin_Number = PIN_15;
 8000e10:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000e14:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOB, &GPIO_pinConfig);
 8000e16:	f107 030c 	add.w	r3, r7, #12
 8000e1a:	4619      	mov	r1, r3
 8000e1c:	4826      	ldr	r0, [pc, #152]	; (8000eb8 <SPI_GPIO_SetPins+0x1dc>)
 8000e1e:	f7ff fcaf 	bl	8000780 <GPIO_init>
			GPIO_pinConfig.MODE = MODE_INPUT_FLO;
 8000e22:	2301      	movs	r3, #1
 8000e24:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Pin_Number = PIN_14;
 8000e26:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000e2a:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOB, &GPIO_pinConfig);
 8000e2c:	f107 030c 	add.w	r3, r7, #12
 8000e30:	4619      	mov	r1, r3
 8000e32:	4821      	ldr	r0, [pc, #132]	; (8000eb8 <SPI_GPIO_SetPins+0x1dc>)
 8000e34:	f7ff fca4 	bl	8000780 <GPIO_init>
}
 8000e38:	e031      	b.n	8000e9e <SPI_GPIO_SetPins+0x1c2>
			if (Global_SPI_pinConfig[SPI2_Index].SPI_Mode == SPI_NSS_Hard_Slave) {
 8000e3a:	4b1c      	ldr	r3, [pc, #112]	; (8000eac <SPI_GPIO_SetPins+0x1d0>)
 8000e3c:	8b1b      	ldrh	r3, [r3, #24]
 8000e3e:	2b00      	cmp	r3, #0
 8000e40:	d10a      	bne.n	8000e58 <SPI_GPIO_SetPins+0x17c>
				GPIO_pinConfig.MODE = MODE_INPUT_FLO;
 8000e42:	2301      	movs	r3, #1
 8000e44:	73bb      	strb	r3, [r7, #14]
				GPIO_pinConfig.Pin_Number = PIN_12;
 8000e46:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000e4a:	81bb      	strh	r3, [r7, #12]
				GPIO_init(GPIOB, &GPIO_pinConfig);
 8000e4c:	f107 030c 	add.w	r3, r7, #12
 8000e50:	4619      	mov	r1, r3
 8000e52:	4819      	ldr	r0, [pc, #100]	; (8000eb8 <SPI_GPIO_SetPins+0x1dc>)
 8000e54:	f7ff fc94 	bl	8000780 <GPIO_init>
			GPIO_pinConfig.MODE = MODE_INPUT_FLO;
 8000e58:	2301      	movs	r3, #1
 8000e5a:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Pin_Number = PIN_13;
 8000e5c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000e60:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOB, &GPIO_pinConfig);
 8000e62:	f107 030c 	add.w	r3, r7, #12
 8000e66:	4619      	mov	r1, r3
 8000e68:	4813      	ldr	r0, [pc, #76]	; (8000eb8 <SPI_GPIO_SetPins+0x1dc>)
 8000e6a:	f7ff fc89 	bl	8000780 <GPIO_init>
			GPIO_pinConfig.MODE = MODE_INPUT_FLO;
 8000e6e:	2301      	movs	r3, #1
 8000e70:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Pin_Number = PIN_15;
 8000e72:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000e76:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOB, &GPIO_pinConfig);
 8000e78:	f107 030c 	add.w	r3, r7, #12
 8000e7c:	4619      	mov	r1, r3
 8000e7e:	480e      	ldr	r0, [pc, #56]	; (8000eb8 <SPI_GPIO_SetPins+0x1dc>)
 8000e80:	f7ff fc7e 	bl	8000780 <GPIO_init>
			GPIO_pinConfig.MODE = MODE_OUTPUT_AF_PP;
 8000e84:	2306      	movs	r3, #6
 8000e86:	73bb      	strb	r3, [r7, #14]
			GPIO_pinConfig.Output_Speed = SPEED_10M;
 8000e88:	2301      	movs	r3, #1
 8000e8a:	73fb      	strb	r3, [r7, #15]
			GPIO_pinConfig.Pin_Number = PIN_14;
 8000e8c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000e90:	81bb      	strh	r3, [r7, #12]
			GPIO_init(GPIOB, &GPIO_pinConfig);
 8000e92:	f107 030c 	add.w	r3, r7, #12
 8000e96:	4619      	mov	r1, r3
 8000e98:	4807      	ldr	r0, [pc, #28]	; (8000eb8 <SPI_GPIO_SetPins+0x1dc>)
 8000e9a:	f7ff fc71 	bl	8000780 <GPIO_init>
}
 8000e9e:	bf00      	nop
 8000ea0:	3710      	adds	r7, #16
 8000ea2:	46bd      	mov	sp, r7
 8000ea4:	bd80      	pop	{r7, pc}
 8000ea6:	bf00      	nop
 8000ea8:	40013000 	.word	0x40013000
 8000eac:	200000ac 	.word	0x200000ac
 8000eb0:	40010800 	.word	0x40010800
 8000eb4:	40003800 	.word	0x40003800
 8000eb8:	40010c00 	.word	0x40010c00

08000ebc <SPI1_IRQHandler>:
	}
	return SPIx->DR;
}

//ISR
void SPI1_IRQHandler(void) {
 8000ebc:	b580      	push	{r7, lr}
 8000ebe:	b082      	sub	sp, #8
 8000ec0:	af00      	add	r7, sp, #0
	struct IRQ_source_t IRQ;
	IRQ.TXE = ((SPI1->SR & (1 << 1)) >> 1);
 8000ec2:	4b12      	ldr	r3, [pc, #72]	; (8000f0c <SPI1_IRQHandler+0x50>)
 8000ec4:	689b      	ldr	r3, [r3, #8]
 8000ec6:	085b      	lsrs	r3, r3, #1
 8000ec8:	f003 0301 	and.w	r3, r3, #1
 8000ecc:	b2da      	uxtb	r2, r3
 8000ece:	793b      	ldrb	r3, [r7, #4]
 8000ed0:	f362 0300 	bfi	r3, r2, #0, #1
 8000ed4:	713b      	strb	r3, [r7, #4]
	IRQ.RXNE = ((SPI1->SR & (1 << 0)) >> 0);
 8000ed6:	4b0d      	ldr	r3, [pc, #52]	; (8000f0c <SPI1_IRQHandler+0x50>)
 8000ed8:	689b      	ldr	r3, [r3, #8]
 8000eda:	f003 0301 	and.w	r3, r3, #1
 8000ede:	b2da      	uxtb	r2, r3
 8000ee0:	793b      	ldrb	r3, [r7, #4]
 8000ee2:	f362 0341 	bfi	r3, r2, #1, #1
 8000ee6:	713b      	strb	r3, [r7, #4]
	IRQ.ERRI = ((SPI1->SR & (1 << 4)) >> 4);
 8000ee8:	4b08      	ldr	r3, [pc, #32]	; (8000f0c <SPI1_IRQHandler+0x50>)
 8000eea:	689b      	ldr	r3, [r3, #8]
 8000eec:	091b      	lsrs	r3, r3, #4
 8000eee:	f003 0301 	and.w	r3, r3, #1
 8000ef2:	b2da      	uxtb	r2, r3
 8000ef4:	793b      	ldrb	r3, [r7, #4]
 8000ef6:	f362 0382 	bfi	r3, r2, #2, #1
 8000efa:	713b      	strb	r3, [r7, #4]
	Global_SPI_pinConfig[SPI1_Index].P_CallBackFun(IRQ);
 8000efc:	4b04      	ldr	r3, [pc, #16]	; (8000f10 <SPI1_IRQHandler+0x54>)
 8000efe:	695b      	ldr	r3, [r3, #20]
 8000f00:	7938      	ldrb	r0, [r7, #4]
 8000f02:	4798      	blx	r3
}
 8000f04:	bf00      	nop
 8000f06:	3708      	adds	r7, #8
 8000f08:	46bd      	mov	sp, r7
 8000f0a:	bd80      	pop	{r7, pc}
 8000f0c:	40013000 	.word	0x40013000
 8000f10:	200000ac 	.word	0x200000ac

08000f14 <SPI2_IRQHandler>:

void SPI2_IRQHandler(void) {
 8000f14:	b580      	push	{r7, lr}
 8000f16:	b082      	sub	sp, #8
 8000f18:	af00      	add	r7, sp, #0
	struct IRQ_source_t IRQ;
	IRQ.TXE = ((SPI2->SR & (1 << 1)) >> 1);
 8000f1a:	4b12      	ldr	r3, [pc, #72]	; (8000f64 <SPI2_IRQHandler+0x50>)
 8000f1c:	689b      	ldr	r3, [r3, #8]
 8000f1e:	085b      	lsrs	r3, r3, #1
 8000f20:	f003 0301 	and.w	r3, r3, #1
 8000f24:	b2da      	uxtb	r2, r3
 8000f26:	793b      	ldrb	r3, [r7, #4]
 8000f28:	f362 0300 	bfi	r3, r2, #0, #1
 8000f2c:	713b      	strb	r3, [r7, #4]
	IRQ.RXNE = ((SPI2->SR & (1 << 0)) >> 0);
 8000f2e:	4b0d      	ldr	r3, [pc, #52]	; (8000f64 <SPI2_IRQHandler+0x50>)
 8000f30:	689b      	ldr	r3, [r3, #8]
 8000f32:	f003 0301 	and.w	r3, r3, #1
 8000f36:	b2da      	uxtb	r2, r3
 8000f38:	793b      	ldrb	r3, [r7, #4]
 8000f3a:	f362 0341 	bfi	r3, r2, #1, #1
 8000f3e:	713b      	strb	r3, [r7, #4]
	IRQ.ERRI = ((SPI2->SR & (1 << 4)) >> 4);
 8000f40:	4b08      	ldr	r3, [pc, #32]	; (8000f64 <SPI2_IRQHandler+0x50>)
 8000f42:	689b      	ldr	r3, [r3, #8]
 8000f44:	091b      	lsrs	r3, r3, #4
 8000f46:	f003 0301 	and.w	r3, r3, #1
 8000f4a:	b2da      	uxtb	r2, r3
 8000f4c:	793b      	ldrb	r3, [r7, #4]
 8000f4e:	f362 0382 	bfi	r3, r2, #2, #1
 8000f52:	713b      	strb	r3, [r7, #4]
	Global_SPI_pinConfig[SPI2_Index].P_CallBackFun(IRQ);
 8000f54:	4b04      	ldr	r3, [pc, #16]	; (8000f68 <SPI2_IRQHandler+0x54>)
 8000f56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000f58:	7938      	ldrb	r0, [r7, #4]
 8000f5a:	4798      	blx	r3
}
 8000f5c:	bf00      	nop
 8000f5e:	3708      	adds	r7, #8
 8000f60:	46bd      	mov	sp, r7
 8000f62:	bd80      	pop	{r7, pc}
 8000f64:	40003800 	.word	0x40003800
 8000f68:	200000ac 	.word	0x200000ac

08000f6c <STK_init>:
 * =======================================================================================
 * 							Generic Functions
 * =======================================================================================
 */

void STK_init() {
 8000f6c:	b480      	push	{r7}
 8000f6e:	af00      	add	r7, sp, #0
#if STK_CLK_SRC == AHB_8
	SYSTICK->CTRL &= ~(1 << 2);
 8000f70:	4b06      	ldr	r3, [pc, #24]	; (8000f8c <STK_init+0x20>)
 8000f72:	681b      	ldr	r3, [r3, #0]
 8000f74:	4a05      	ldr	r2, [pc, #20]	; (8000f8c <STK_init+0x20>)
 8000f76:	f023 0304 	bic.w	r3, r3, #4
 8000f7a:	6013      	str	r3, [r2, #0]
	microSecond = 1;		// Assuming system clock is HSI
 8000f7c:	4b04      	ldr	r3, [pc, #16]	; (8000f90 <STK_init+0x24>)
 8000f7e:	2201      	movs	r2, #1
 8000f80:	601a      	str	r2, [r3, #0]
#elif STK_CLK_SRC =AHB
	SYSTICK->CTRL |= (1<<2);
	microSecond = 8;		// Assuming system clock is HSI
#endif

}
 8000f82:	bf00      	nop
 8000f84:	46bd      	mov	sp, r7
 8000f86:	bc80      	pop	{r7}
 8000f88:	4770      	bx	lr
 8000f8a:	bf00      	nop
 8000f8c:	e000e010 	.word	0xe000e010
 8000f90:	200000dc 	.word	0x200000dc

08000f94 <STK_delayMs>:
	SYSTICK->VAL = 0;
	SYSTICK->CTRL &= ~(1<<0);

}

void STK_delayMs(uint32 time) {
 8000f94:	b480      	push	{r7}
 8000f96:	b085      	sub	sp, #20
 8000f98:	af00      	add	r7, sp, #0
 8000f9a:	6078      	str	r0, [r7, #4]
	for (uint32 i=0; i < time; i++) {
 8000f9c:	2300      	movs	r3, #0
 8000f9e:	60fb      	str	r3, [r7, #12]
 8000fa0:	e029      	b.n	8000ff6 <STK_delayMs+0x62>
		SYSTICK->LOAD = 1000*microSecond;
 8000fa2:	4b1a      	ldr	r3, [pc, #104]	; (800100c <STK_delayMs+0x78>)
 8000fa4:	681b      	ldr	r3, [r3, #0]
 8000fa6:	4a1a      	ldr	r2, [pc, #104]	; (8001010 <STK_delayMs+0x7c>)
 8000fa8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8000fac:	fb01 f303 	mul.w	r3, r1, r3
 8000fb0:	6053      	str	r3, [r2, #4]
		//Disable Interrupt
		CLEAR(SYSTICK->CTRL, 1);
 8000fb2:	4b17      	ldr	r3, [pc, #92]	; (8001010 <STK_delayMs+0x7c>)
 8000fb4:	681b      	ldr	r3, [r3, #0]
 8000fb6:	4a16      	ldr	r2, [pc, #88]	; (8001010 <STK_delayMs+0x7c>)
 8000fb8:	f023 0302 	bic.w	r3, r3, #2
 8000fbc:	6013      	str	r3, [r2, #0]
		//Enable Systick
		SET(SYSTICK->CTRL, 0);
 8000fbe:	4b14      	ldr	r3, [pc, #80]	; (8001010 <STK_delayMs+0x7c>)
 8000fc0:	681b      	ldr	r3, [r3, #0]
 8000fc2:	4a13      	ldr	r2, [pc, #76]	; (8001010 <STK_delayMs+0x7c>)
 8000fc4:	f043 0301 	orr.w	r3, r3, #1
 8000fc8:	6013      	str	r3, [r2, #0]
		//Wait for flag
		while (!GET(SYSTICK->CTRL, 16))
 8000fca:	bf00      	nop
 8000fcc:	4b10      	ldr	r3, [pc, #64]	; (8001010 <STK_delayMs+0x7c>)
 8000fce:	681b      	ldr	r3, [r3, #0]
 8000fd0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000fd4:	2b00      	cmp	r3, #0
 8000fd6:	d0f9      	beq.n	8000fcc <STK_delayMs+0x38>
			;
		//Disable Systick
		SYSTICK->LOAD = 0;
 8000fd8:	4b0d      	ldr	r3, [pc, #52]	; (8001010 <STK_delayMs+0x7c>)
 8000fda:	2200      	movs	r2, #0
 8000fdc:	605a      	str	r2, [r3, #4]
		SYSTICK->VAL = 0;
 8000fde:	4b0c      	ldr	r3, [pc, #48]	; (8001010 <STK_delayMs+0x7c>)
 8000fe0:	2200      	movs	r2, #0
 8000fe2:	609a      	str	r2, [r3, #8]
		CLEAR(SYSTICK->CTRL, 0);
 8000fe4:	4b0a      	ldr	r3, [pc, #40]	; (8001010 <STK_delayMs+0x7c>)
 8000fe6:	681b      	ldr	r3, [r3, #0]
 8000fe8:	4a09      	ldr	r2, [pc, #36]	; (8001010 <STK_delayMs+0x7c>)
 8000fea:	f023 0301 	bic.w	r3, r3, #1
 8000fee:	6013      	str	r3, [r2, #0]
	for (uint32 i=0; i < time; i++) {
 8000ff0:	68fb      	ldr	r3, [r7, #12]
 8000ff2:	3301      	adds	r3, #1
 8000ff4:	60fb      	str	r3, [r7, #12]
 8000ff6:	68fa      	ldr	r2, [r7, #12]
 8000ff8:	687b      	ldr	r3, [r7, #4]
 8000ffa:	429a      	cmp	r2, r3
 8000ffc:	d3d1      	bcc.n	8000fa2 <STK_delayMs+0xe>
	}
}
 8000ffe:	bf00      	nop
 8001000:	bf00      	nop
 8001002:	3714      	adds	r7, #20
 8001004:	46bd      	mov	sp, r7
 8001006:	bc80      	pop	{r7}
 8001008:	4770      	bx	lr
 800100a:	bf00      	nop
 800100c:	200000dc 	.word	0x200000dc
 8001010:	e000e010 	.word	0xe000e010

08001014 <SysTick_Handler>:
uint32 STK_getRemainingTime() {
	return (SYSTICK->VAL);

}

void SysTick_Handler() {
 8001014:	b580      	push	{r7, lr}
 8001016:	b082      	sub	sp, #8
 8001018:	af00      	add	r7, sp, #0
	uint8 flag = 0;
 800101a:	2300      	movs	r3, #0
 800101c:	71fb      	strb	r3, [r7, #7]
#if STK_MODE == SINGLE
	SYSTICK->LOAD = 0;
 800101e:	4b0e      	ldr	r3, [pc, #56]	; (8001058 <SysTick_Handler+0x44>)
 8001020:	2200      	movs	r2, #0
 8001022:	605a      	str	r2, [r3, #4]
	SYSTICK->VAL = 0;
 8001024:	4b0c      	ldr	r3, [pc, #48]	; (8001058 <SysTick_Handler+0x44>)
 8001026:	2200      	movs	r2, #0
 8001028:	609a      	str	r2, [r3, #8]
	CLEAR(SYSTICK->CTRL, 0);
 800102a:	4b0b      	ldr	r3, [pc, #44]	; (8001058 <SysTick_Handler+0x44>)
 800102c:	681b      	ldr	r3, [r3, #0]
 800102e:	4a0a      	ldr	r2, [pc, #40]	; (8001058 <SysTick_Handler+0x44>)
 8001030:	f023 0301 	bic.w	r3, r3, #1
 8001034:	6013      	str	r3, [r2, #0]
	CLEAR(SYSTICK->CTRL, 1);
 8001036:	4b08      	ldr	r3, [pc, #32]	; (8001058 <SysTick_Handler+0x44>)
 8001038:	681b      	ldr	r3, [r3, #0]
 800103a:	4a07      	ldr	r2, [pc, #28]	; (8001058 <SysTick_Handler+0x44>)
 800103c:	f023 0302 	bic.w	r3, r3, #2
 8001040:	6013      	str	r3, [r2, #0]
#endif

	P_CallBack_Fun();
 8001042:	4b06      	ldr	r3, [pc, #24]	; (800105c <SysTick_Handler+0x48>)
 8001044:	681b      	ldr	r3, [r3, #0]
 8001046:	4798      	blx	r3
	flag = GET(SYSTICK->CTRL, 16);
 8001048:	4b03      	ldr	r3, [pc, #12]	; (8001058 <SysTick_Handler+0x44>)
 800104a:	681b      	ldr	r3, [r3, #0]
 800104c:	2300      	movs	r3, #0
 800104e:	71fb      	strb	r3, [r7, #7]
}
 8001050:	bf00      	nop
 8001052:	3708      	adds	r7, #8
 8001054:	46bd      	mov	sp, r7
 8001056:	bd80      	pop	{r7, pc}
 8001058:	e000e010 	.word	0xe000e010
 800105c:	200000e0 	.word	0x200000e0

08001060 <USART1_IRQHandler>:
	// Add the null terminator at the end of the received string.
	buffer[index] = '\0';
}

// ISR
void USART1_IRQHandler() {
 8001060:	b580      	push	{r7, lr}
 8001062:	af00      	add	r7, sp, #0
	Global_pinConfig[USART1_Index].P_CallBack_Fun();
 8001064:	4b02      	ldr	r3, [pc, #8]	; (8001070 <USART1_IRQHandler+0x10>)
 8001066:	691b      	ldr	r3, [r3, #16]
 8001068:	4798      	blx	r3
}
 800106a:	bf00      	nop
 800106c:	bd80      	pop	{r7, pc}
 800106e:	bf00      	nop
 8001070:	200000e4 	.word	0x200000e4

08001074 <USART2_IRQHandler>:
void USART2_IRQHandler() {
 8001074:	b580      	push	{r7, lr}
 8001076:	af00      	add	r7, sp, #0
	Global_pinConfig[USART2_Index].P_CallBack_Fun();
 8001078:	4b02      	ldr	r3, [pc, #8]	; (8001084 <USART2_IRQHandler+0x10>)
 800107a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800107c:	4798      	blx	r3
}
 800107e:	bf00      	nop
 8001080:	bd80      	pop	{r7, pc}
 8001082:	bf00      	nop
 8001084:	200000e4 	.word	0x200000e4

08001088 <USART3_IRQHandler>:
void USART3_IRQHandler() {
 8001088:	b580      	push	{r7, lr}
 800108a:	af00      	add	r7, sp, #0
	Global_pinConfig[USART3_Index].P_CallBack_Fun();
 800108c:	4b02      	ldr	r3, [pc, #8]	; (8001098 <USART3_IRQHandler+0x10>)
 800108e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001090:	4798      	blx	r3
}
 8001092:	bf00      	nop
 8001094:	bd80      	pop	{r7, pc}
 8001096:	bf00      	nop
 8001098:	200000e4 	.word	0x200000e4

0800109c <main>:
#include "main.h"
int main() {
 800109c:	b580      	push	{r7, lr}
 800109e:	af00      	add	r7, sp, #0

RCC_CLK_EN(APB2_ID,GPIOA_ID);
 80010a0:	2102      	movs	r1, #2
 80010a2:	2001      	movs	r0, #1
 80010a4:	f7ff fd38 	bl	8000b18 <RCC_CLK_EN>

  Led_Matrix_init(SPI1,PIN_4,GPIOA);
 80010a8:	4a04      	ldr	r2, [pc, #16]	; (80010bc <main+0x20>)
 80010aa:	2110      	movs	r1, #16
 80010ac:	4804      	ldr	r0, [pc, #16]	; (80010c0 <main+0x24>)
 80010ae:	f7ff f85f 	bl	8000170 <Led_Matrix_init>



while(1) {
	Led_Matrix_writeString("PIZA");
 80010b2:	4804      	ldr	r0, [pc, #16]	; (80010c4 <main+0x28>)
 80010b4:	f7ff f94c 	bl	8000350 <Led_Matrix_writeString>
 80010b8:	e7fb      	b.n	80010b2 <main+0x16>
 80010ba:	bf00      	nop
 80010bc:	40010800 	.word	0x40010800
 80010c0:	40013000 	.word	0x40013000
 80010c4:	0800117c 	.word	0x0800117c

080010c8 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80010c8:	480d      	ldr	r0, [pc, #52]	; (8001100 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80010ca:	4685      	mov	sp, r0
/* Call the clock system intitialization function.*/
  bl  SystemInit
 80010cc:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80010d0:	480c      	ldr	r0, [pc, #48]	; (8001104 <LoopForever+0x6>)
  ldr r1, =_edata
 80010d2:	490d      	ldr	r1, [pc, #52]	; (8001108 <LoopForever+0xa>)
  ldr r2, =_sidata
 80010d4:	4a0d      	ldr	r2, [pc, #52]	; (800110c <LoopForever+0xe>)
  movs r3, #0
 80010d6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80010d8:	e002      	b.n	80010e0 <LoopCopyDataInit>

080010da <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80010da:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80010dc:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80010de:	3304      	adds	r3, #4

080010e0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80010e0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80010e2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80010e4:	d3f9      	bcc.n	80010da <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80010e6:	4a0a      	ldr	r2, [pc, #40]	; (8001110 <LoopForever+0x12>)
  ldr r4, =_ebss
 80010e8:	4c0a      	ldr	r4, [pc, #40]	; (8001114 <LoopForever+0x16>)
  movs r3, #0
 80010ea:	2300      	movs	r3, #0
  b LoopFillZerobss
 80010ec:	e001      	b.n	80010f2 <LoopFillZerobss>

080010ee <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80010ee:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80010f0:	3204      	adds	r2, #4

080010f2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80010f2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80010f4:	d3fb      	bcc.n	80010ee <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80010f6:	f000 f811 	bl	800111c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80010fa:	f7ff ffcf 	bl	800109c <main>

080010fe <LoopForever>:

LoopForever:
    b LoopForever
 80010fe:	e7fe      	b.n	80010fe <LoopForever>
  ldr   r0, =_estack
 8001100:	20002800 	.word	0x20002800
  ldr r0, =_sdata
 8001104:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001108:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 800110c:	080012e4 	.word	0x080012e4
  ldr r2, =_sbss
 8001110:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 8001114:	20000120 	.word	0x20000120

08001118 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001118:	e7fe      	b.n	8001118 <ADC1_2_IRQHandler>
	...

0800111c <__libc_init_array>:
 800111c:	b570      	push	{r4, r5, r6, lr}
 800111e:	2600      	movs	r6, #0
 8001120:	4d0c      	ldr	r5, [pc, #48]	; (8001154 <__libc_init_array+0x38>)
 8001122:	4c0d      	ldr	r4, [pc, #52]	; (8001158 <__libc_init_array+0x3c>)
 8001124:	1b64      	subs	r4, r4, r5
 8001126:	10a4      	asrs	r4, r4, #2
 8001128:	42a6      	cmp	r6, r4
 800112a:	d109      	bne.n	8001140 <__libc_init_array+0x24>
 800112c:	f000 f81a 	bl	8001164 <_init>
 8001130:	2600      	movs	r6, #0
 8001132:	4d0a      	ldr	r5, [pc, #40]	; (800115c <__libc_init_array+0x40>)
 8001134:	4c0a      	ldr	r4, [pc, #40]	; (8001160 <__libc_init_array+0x44>)
 8001136:	1b64      	subs	r4, r4, r5
 8001138:	10a4      	asrs	r4, r4, #2
 800113a:	42a6      	cmp	r6, r4
 800113c:	d105      	bne.n	800114a <__libc_init_array+0x2e>
 800113e:	bd70      	pop	{r4, r5, r6, pc}
 8001140:	f855 3b04 	ldr.w	r3, [r5], #4
 8001144:	4798      	blx	r3
 8001146:	3601      	adds	r6, #1
 8001148:	e7ee      	b.n	8001128 <__libc_init_array+0xc>
 800114a:	f855 3b04 	ldr.w	r3, [r5], #4
 800114e:	4798      	blx	r3
 8001150:	3601      	adds	r6, #1
 8001152:	e7f2      	b.n	800113a <__libc_init_array+0x1e>
 8001154:	080012dc 	.word	0x080012dc
 8001158:	080012dc 	.word	0x080012dc
 800115c:	080012dc 	.word	0x080012dc
 8001160:	080012e0 	.word	0x080012e0

08001164 <_init>:
 8001164:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001166:	bf00      	nop
 8001168:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800116a:	bc08      	pop	{r3}
 800116c:	469e      	mov	lr, r3
 800116e:	4770      	bx	lr

08001170 <_fini>:
 8001170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001172:	bf00      	nop
 8001174:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001176:	bc08      	pop	{r3}
 8001178:	469e      	mov	lr, r3
 800117a:	4770      	bx	lr
